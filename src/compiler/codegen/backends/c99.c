#include "../backend.h"

#include "codegen/codegen.h"
#include "error/error.h"
#include "ir/ir.h"
#include "list.h"
#include "platform/linux/linux_platform.h"
#include "io/log.h"

#include <stdint.h>

#define P(...) codegen_printf(c, __VA_ARGS__)
#define P_ln(...) codegen_println(c, __VA_ARGS__)

struct BACKEND_DATA_STRUCT {
    List_T* generated_types;
};

static size_t C99_get_type_id(CodegenData_T* c, IRType_T* type)
{
    // TODO: optimize this
    for(size_t i = 0; i < c->ir->types->size; i++)
        if(c->ir->types->items[i] == type)
            return i;
    unreachable();
    return SIZE_MAX;
}

static void C99_generate_type(CodegenData_T* c, IRType_T* type)
{
#define PRIMITIVE(en, ct) case IR_TYPE_##en: P(#ct); break;

    switch(type->kind)
    {
        PRIMITIVE(I8, int8_t);
        PRIMITIVE(I16, int16_t);
        PRIMITIVE(I32, int32_t);
        PRIMITIVE(I64, int64_t);
        PRIMITIVE(U8, uint8_t);
        PRIMITIVE(U16, uint16_t);
        PRIMITIVE(U32, uint32_t);
        PRIMITIVE(U64, uint64_t);
        PRIMITIVE(F32, float);
        PRIMITIVE(F64, double);
        PRIMITIVE(F80, long double);
        PRIMITIVE(VOID, void);

        case IR_TYPE_STRUCT:
        case IR_TYPE_VLA:
        case IR_TYPE_ARRAY:
            P("struct _%zu", C99_get_type_id(c, type));
            break;
        case IR_TYPE_UNION:
            P("union _%zu", C99_get_type_id(c, type));
            break;
        case IR_TYPE_PTR:
            C99_generate_type(c, type->base);
            P("*");
            break;
        case IR_TYPE_C_ARRAY:
            P("_array_%zu", C99_get_type_id(c, type));
            break;
        case IR_TYPE_FN:
            P("_fn_%zu", C99_get_type_id(c, type));
            break;
        default:
            unreachable();

    }

#undef PRIMITIVE
}

static void C99_define_type(CodegenData_T* c, IRType_T* type, size_t i)
{
    if(list_contains(c->b_data->generated_types, type))
        return;

    switch(type->kind)
    {
    case IR_TYPE_STRUCT:
    case IR_TYPE_UNION:
        for(size_t i = 0; i < type->fields->size; i++)
        {
            IRTypeField_T* field = type->fields->items[i];
            C99_define_type(c, field->type, C99_get_type_id(c, field->type));
        }

        P_ln("%s _%zu {", type->kind == IR_TYPE_STRUCT ? "struct" : "union", i);
        for(size_t i = 0; i < type->fields->size; i++)
        {
            IRTypeField_T* field = type->fields->items[i];
            P("  ");
            C99_generate_type(c, field->type);
            P_ln(" %s;", field->id);
        }
        P_ln("};");
        break;
    case IR_TYPE_ARRAY:
    case IR_TYPE_VLA:
        C99_define_type(c, type->base, C99_get_type_id(c, type->base));
        P_ln("struct _%zu {", i);
        P_ln("  uint64_t len;");
        C99_generate_type(c, type->base);
        P_ln(" data[%zu]", type->kind == IR_TYPE_VLA ? 0 : type->indices);
        P_ln("};");
        break;
    case IR_TYPE_C_ARRAY:
        C99_define_type(c, type->base, C99_get_type_id(c, type->base));
        P("typedef ");
        C99_generate_type(c, type->base);
        P_ln(" _array_%zu[%zu];", i, type->indices);
        break;
    case IR_TYPE_FN:
        P("typedef ");
        C99_generate_type(c, type->base);
        P(" (* _fn_%zu)(", i);
        if(type->fn.arguments->size)
        {
            for(size_t i = 0; i < type->fn.arguments->size; i++)
            {
                C99_generate_type(c, type->fn.arguments->items[i]);
                if(type->fn.arguments->size - i > 1)
                    P(", ");
            }
            if(type->fn.variadic)
                P(", ...");
        }
        else if(type->fn.variadic)
            P("...");
        else
            P("void");
        P_ln(");");
        break;
    default:
        return;
    }

    list_push(c->b_data->generated_types, type);
}

static void C99_begin_file(CodegenData_T* c)
{
    c->b_data = calloc(1, sizeof(struct BACKEND_DATA_STRUCT));
    c->b_data->generated_types = init_list();

    P_ln("// generated by cspc");
    P_ln("#include <stdint.h>");

    for(size_t i = 0; i < c->ir->types->size; i++)
        C99_define_type(c, c->ir->types->items[i], i); 
}

static void C99_finish_file(CodegenData_T* c)
{
    P_ln("int main() { return 0; }");

    free_list(c->b_data->generated_types);
    free(c->b_data);
}

static void C99_compile(CodegenData_T* c, const char* input_file, const char* output_file)
{
    List_T* args = init_list(); 

    list_push(args, c->context->cc);
    list_push(args, "-c");
    list_push(args, (void*) input_file);
    list_push(args, "-std=c99");
    list_push(args, "-o");
    list_push(args, (void*) output_file);

    if(c->generate_debug_info)
        list_push(args, "-g");

    for(size_t i = 0; i < c->context->compiler_flags->size; i++)
        list_push(args, c->context->compiler_flags->items[i]);

    if(c->context->flags.optimize)
        list_push(args, "-O2"); // -O3 is known to cause issues

    list_push(args, NULL);

    i32 exit_code = subprocess(args->items[0], (char* const*) args->items, false);
    free_list(args);

    if(exit_code != 0)
    {
        LOG_ERROR_F(COLOR_BOLD_RED "[Error]" COLOR_RESET COLOR_RED "C compiler terminated with non-zero exit code %d.\n" COLOR_RESET, exit_code);
        throw(c->context->main_error_exception);
    }
}

BACKEND_CALLBACKS_IMPL_EXT(C99);
