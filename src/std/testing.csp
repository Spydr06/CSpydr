import "error.csp";
import "process.csp";

namespace std {
    type Testing: struct {
        successful: u64,
        tests: &(std::testing::Test[]),
        current: u64,
        errors: i32
    };

    namespace testing {
        type Test: struct {
            func: const fn(&Testing),
            desc: &const char
        };

        fn new(tests: Test[]): std::Testing {
            <- Testing::{
                0, &tests
            };
        }

        fn run(t: &Testing, idx: u64): bool {
            do {
                error::new(std::Errno::NILPTR, "argument t is nil or contains no tests");
                <- false;
            } unless t && t.tests;

            if idx >= len *t.tests {
                error::new(std::Errno::INDEXOUTOFBOUNDS, "idx bigger than t.tests array");
                <- false;
            }

            let test = (*t.tests)[idx];
            do {
                error::new(std::Errno::NILPTR, "t.tests[idx] is nil");
                <- false;
            } unless test && test.func;

            t.errors = 0;
            t.current = idx;

            io::printf("Running test %l/%l: `%s`", idx + 1, len *t.tests, test.desc);

            using process;
            let pid = fork();
            match pid {
                (-1): pid_t => {
                    error::new(std::Errno::CHILD, "could not fork process");
                    <- false;
                }
                0 => {
                    # new child process
                    test.func(t);
                    exit(t.errors); # pass the number of errors through the exit status to the parent process
                }
                _ => {
                    # parent process
                    let exit_code = 0;
                    waitpid(pid, &exit_code, 0);
                    if exited(exit_code)
                        t.errors += exit_status(exit_code); # the exit status marks the number of errors
                    else if signaled(exit_code) {
                        let signame = signum_str(term_sig(exit_code));

                        using io::color;
                        io::printf("\n    %sTest `%s` (%i) terminated with signal %s.%s", &RED[0], test.desc, idx + 1, signame, &RESET[0]);
                        t.errors ++;
                    }
                    else {
                        using io::color;
                        io::printf("\n   %sTest `%s` (%i) terminated in an unexpected way.%s", &RED[0], test.desc, idx + 1, &RESET[0]);
                        t.errors++;
                    }
                }
            }

            using io::color;
            match t.errors {
                0 => {
                    io::printf("\t[ %s%sOK%s ]\n", &GREEN[0], &BOLD[0], &RESET[0]);
                    t.errors = 0;
                    <- true;
                }
                _ => {
                    io::printf("\t[%s%sFAIL%s]\n", &RED[0], &BOLD[0], &RESET[0]);
                    t.errors = 0;
                    <- false;
                }
            }

        }

        fn run_all(t: &Testing): u64 {
            do {
                error::new(std::Errno::NILPTR, "argument t is nil or contains no tests");
                <- 0;
            } unless t && t.tests;

            t.successful = 0;

            for let i: u64 = 0; i < len *t.tests; i++; {
                if run(t, i)
                    t.successful++;
            }

            using io::color;
            if t.successful == len *t.tests {
                io::printf("[ %s%sOK%s ] All %l tests finished successfully.\n", &GREEN[0], &BOLD[0], &RESET[0], t.successful);
                <- 0;
            }
            else {
                let failed = (len *t.tests) - t.successful;
                io::printf("[%s%sFAIL%s] %l of %l tests failed, %l finished successfully.\n", &RED[0], &BOLD[0], &RESET[0], failed, len *t.tests, t.successful);
                <- failed;
            }
        }

        fn assert(t: &Testing, condition: bool, error_msg: &const char) {
            do {
                error::new(std::Errno::NILPTR, "argument t is nil");
                ret;
            } unless t && t.tests;

            using io::color;
            do {
                io::eprintf("\n    %sTest `%s` (%l): assertion failed: %s%s", &RED[0], (*t.tests)[t.current].desc, t.current + 1, error_msg, &RESET[0]);
                t.errors++;
            } unless condition;
        }

        fn assert_false(t: &Testing, condition: bool, error_msg: &const char) {
            assert(t, !condition, error_msg);
        }
    }
}