import "mem.csp";
import "types.csp";
import "utils.csp";
import "option.csp";
import "math.csp";
import "vec.csp";

# a macro to crate a string
macro str() {
    (::std::string::init(nil))
}

macro str(chptr) {
    (::std::string::init((chptr): &char))
}

# a macro to concatenate two strings
macro concat(a, b) {
    (::std::string::concat(&(a), (b)));
}

# convert any given value to a string
macro to_str(v) {
    (
        if (type) __is_int(typeof (v))
            => ::std::string::from_int(v)
        else if (type) __is_uint(typeof (v))
            => ::std::string::from_uint(v)
        else if (type) (typeof (v)) == bool
            => if (v) == true =>
                str!{"true"}
            else
                str!{"false"}
        else if (type) (typeof (v)) == void
            => str!{"void"}
        else if (type) (typeof (v)) == char
            => ::std::string::from_char(v)
        else if (type) (typeof (v)) == ::std::String
            => (v)
        else if (type) (typeof (v)) == &char
            => ::std::string::init(v)
        else str! {nil}
    )
}

namespace std {
    type String: &char;

    namespace string {
        type StringData: struct {
            alloc: u64,
            size: u64,
            buff: char[]
        };

        fn init(value: String): ::std::String 
        {
            let str_data: &StringData;

            if value == nil {
                str_data = mem::alloc(sizeof StringData);
                str_data.alloc = 1;
                str_data.size = 0;
            }
            else {
                let v_len = c_str::get_len(value);
                str_data = mem::alloc(sizeof StringData + v_len + 1);
                str_data.alloc = v_len;
                str_data.size = v_len;
                
                c_str::copy(str_data.buff, value);
            }
            <- &(str_data.buff[0]);
        }

        fn free(str: String) 
        {
            mem::free(get_data(str));
        } 

        fn get_data(str: String): &StringData 
        {
            <- &(str: &StringData)[-1];
        }

        fn concat(dest: &String, src: String) 
        {
            let str_data = get_data(*dest);
            let str_len = c_str::get_len(*dest);
            str_data.alloc = str_data.alloc + c_str::get_len(src);
            str_data.size = str_data.size + c_str::get_len(src);
            str_data = mem::realloc(str_data, sizeof StringData + str_data.alloc + 1);
            c_str::copy(&(str_data.buff[str_len]), src);

            str_data.buff[str_len + c_str::get_len(src)] = '\0';
            *dest = &(str_data.buff[0]);
        }

        fn copy(str: String): ::std::String 
        {   
            <- init(str);
        }

        fn contains(str: String, substr: String): bool 
        {
            <- c_str::strstr(str, substr) != nil;
        }

        # checks if a string contains a char
        fn contains_char(str: String, c: char): bool
        {
            if !str ret false;
            for let i: usize = 0; i < c_str::get_len(str); i++; {
                if str[i] == c ret true;
            }
            <- false;
        }

        # finds a char in a string and returns the index of the first found char
        fn find_char(str: String, c: char): std::Option
        {
            if !str ret none!();
            for let i: usize = 0; i < c_str::get_len(str); i++; {
                if str[i] == c ret some!(i);
            }
            <- none!();
        }

        fn split(str: String, delim: String): &::std::String {
            let str_vec = vec![String];
 
            let token: &char;
            while (token = c_str::strsep(&str, delim)) != nil {
                let part = init(token);
                vec_add!(str_vec, part);
            }
 
            <- str_vec;
        }

        fn size(str: String): u64 
        {
            <- c_str::get_len(str);
        }

        fn substr(str: ::std::String, from: i64, to: i64): ::std::String 
        {
            if to - from < 0 || to - from >= size(str)
                 ret nil;

            let ch_arr: &char = mem::alloc((to - from + 2) * sizeof char);
            for let i: i64 = from; i < to; i++; {
                ch_arr[i - from] = str[i];
            }
            #ch_arr[from - to] = '\0';
            
            let sub_str = init(ch_arr);
            mem::free(ch_arr);
            <- sub_str;
        }

        fn from_int(int: i64): ::std::String
        {
            let buf: char[100];
            c_str::from_int(int, buf, 10);
            <- str!{buf};
        }

        fn from_uint(uint: u64): ::std::String
        {
            let buf: char[100];
            c_str::from_uint(uint, buf, 10);
            <- str!{buf};
        }

        fn from_char(c: char): ::std::String
        {
            <- str!{[c, '\0']};
        }

        fn format(fmt: const &char, args: ...): &void
            <- va_format(fmt, args);

        fn va_format(fmt: const &char, args: &va::Element): &void
        {
            let str = str!{};

            <- nil;
        }
    }

    namespace c_str {
        type LongWord: u64;

        namespace __static {
            let __strtok_old: &char = nil;
        }

        # gets the length of a traditional C string without the null terminator
        fn get_len(str: const &char): usize
        {
            let length: usize = 0;
            while str[length] != nil length++;
            <- length;
        }

        fn strlen(str: const &char): usize
            <- get_len(str);

        # similar to c_str::copy
        fn copy(dest: &char, src: const &char)
        {
            mem::move(dest, src, get_len(src));
        }

        fn strcpy(dest: &char, src: const &char)
            copy(dest, src);
        
        fn strncpy(s1: &char, s2: const &char, n: usize): &char 
        {
            let size = strnlen(s2, n);
            if size != n
                mem::set(s1 + size, '\0', n - size);
            <- mem::copy(s1, s2, size);
        }

        fn strcat(dest: &char, src: const &char): &char
        {
            strcpy(dest + strlen(dest), src);
            <- dest;
        }

        fn strstr(str: &char, substr: &char): &char
        {
            let size: usize = get_len(substr);
            let ref = substr;

            while (*str) != 0 && (*ref) != 0 {
                if (*str)++ == (*ref) ref++;
                if (*ref) == 0 ret str - size;
                if (size == (ref - substr)) 
                    ref = substr;
            }

            <- nil;
        }

        fn strsep(stringp: &&char, delim: const &char): &char
        {
            let begin = *stringp;
            if begin == nil ret nil;

            let end: &char = begin + strspn(begin, delim);

            if (*end) != 0 {
                (*end)++;
                (*stringp) = end;
            }
            else
                (*stringp) = nil;
            
            <- begin;
        }
        
        # Return the length of the maximum initial segment
        # of S which contains only characters in ACCEPT.
        fn strspn(s: const &char, accept: const &char): usize
        {
            let n: usize = 0;
            let p: &char = nil;

            for n = 0; *s; n++; {
                s++;
                for p = accept; (*p) != '\0' && (*p) != *s; p++;
                    noop;
                if !*p
                    break;
            }

            <- n;
        }
        
        # Return the length of the maximum initial segment of S
        # which contains no characters from REJECT.
        fn strcspn(str: &char, reject: const &char): usize
        {
            let size: usize = 0;

            if (str == nil) || (reject == nil)
                <- nil;
            
            while *str {
                if strchr(reject, *str)
                    <- size;
                str++;
                size++;
            }

            <- size;
        }
        
        # Find the first occurrence of C in S.
        fn strchr(s: const &char, c_in: i32): const &char
        {
            if s == nil || c_in > 255 || c_in < 0
                <- nil;
        
            let s_len = strlen(s);
            for let i: usize = 0; i < s_len; i++;
                if (c_in: char) == s[i]
                    <- (&s[i]): const &char;

            <- nil;
        }
        
        # Find the first occurrence in S of any character in ACCEPT.
        fn strpbrk(s: &char, accept: const &char): &char
        {
            s += strcspn(s, accept);
            <- if (*s) != '\0' => s: &char else nil;
        }

        #[ 
            Parse S into tokens separated by characters in DELIM.
            If S is NULL, the last string strtok() was called with is
            used.  For example:
	        char s[] = "-abc-=-def";
	        x = strtok(s, "-");		// x = "abc"
	        x = strtok(NULL, "-=");		// x = "def"
	        x = strtok(NULL, "=");		// x = NULL
		    // s = "abc\0=-def\0"
        ]#
        fn strtok(s: &char, delim: const &char): &char
        {
            if s == nil 
                s = __static::__strtok_old;
            
            # scan leading delimeters
            s += strspn(s, delim);
            if (*s) == '\0' {
                __static::__strtok_old = s;
                <- nil;
            }

            # find the end of the token
            let token = s;
            s = strpbrk(token, delim);
            if s == nil
                __static::__strtok_old = rawmemchr(token, '\0');
            else {
                (*s) = '\0';
                __static::__strtok_old = s + 1;
            }

            <- token;
        }
        
        # Search no more than N bytes of S for C.
        fn memchr(s: const &void, c_in: i32, n: usize): &void
        {
            let c = c_in: u8;
            let ch_ptr: &u8;

            for ch_ptr = (s: const &u8); n > 0 && (ch_ptr: u64 % sizeof LongWord) != 0; n--; {
                ch_ptr++;
                if (*ch_ptr) == c
                    <- ch_ptr: &void;
            }

            let longword_ptr = ch_ptr: &LongWord;
            let repeated_one: LongWord = 0x01010101;
            let repeated_c: LongWord = c | (c << 8);
            if 0xffffffff: u64 < (-1: LongWord) {
                repeated_one |= repeated_one << 31 << 1;
                repeated_c |= repeated_c << 31 << 1;
            }

            while n >= sizeof LongWord {
                let longword1: LongWord = (*longword_ptr) ^ repeated_c;

                if (((longword1 - repeated_one) & ~longword1) & (repeated_one << 7)) != 0
                    break;

                longword_ptr++;
                n -= sizeof LongWord;
            }

            ch_ptr = longword_ptr: const &u8;

            for ; n > 0; n--; {
                ch_ptr++;
                if (*ch_ptr) == c
                    <- ch_ptr: &void;
            }

            <- nil;
        }

        fn rawmemchr(s: const &void, c: i32): &void
        {
            if c != '\0' 
                <- memchr(s, c, (-1): usize);
            <- (s + strlen(s)): &char;
        }

        fn reverse(str: &char)
        {
            let size = get_len(str);
            for let i: usize = 0; i < size / 2; i++;
                swap!(str[i], str[size - i - 1]);
        }

        fn from_int(num: i64, str: &char, base: i32): &char 
        {
            let i: i64 = 0;
            let is_negative: bool = false;

            if num == 0 {
                str[i++] = '0';
                str[i] = '\0';
                <- str;
            }

            if num < 0 && base == 10 {
                is_negative = true;
                num = -num;
            }

            while num != 0 {
                let rem: i64 = num % base;
                if rem > 9 
                    str[i++] = ((rem - 10) + 'a');
                else
                    str[i++] = rem + '0';
                num = num / base;
            }

            if is_negative
                str[i++] = '-';

            str[i] = '\0';
            reverse(str);
            
            <- str;
        }

        fn from_uint(num: u64, str: &char, base: i32): &char 
        {
            let i: u64 = 0;

            if num == 0 {
                str[i++] = '0';
                str[i] = '\0';
                <- str;
            }

            while num != 0 {
                let rem: u64 = num % base;
                if rem > 9 
                    str[i++] = ((rem - 10) + 'a');
                else
                    str[i++] = rem + '0';
                num = num / base;
            }

            str[i] = '\0';
            reverse(str);
            <- str;
        }

        fn from_bool(b: bool, str: &char): &char
        {
            copy(str, if b => "true" else "false");
            <- str;
        }
    }
}