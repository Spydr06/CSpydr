import "mem.csp";
import "types.csp";
import "utils.csp";
import "option.csp";
import "math.csp";
import "vec.csp";
import "c_str.csp";
import "error.csp";

# a macro to crate a string
macro str() {
    (::std::string::init(nil))
}

macro str(chptr) {
    (::std::string::init((chptr): &char))
}

# a macro to concatenate two strings
macro concat(a, b) {
    (::std::string::concat(&(a), (b)));
}

# convert any given value to a string
macro to_str(v) {
    (
        if type::is_int(typeof (v))
            => ::std::string::from_int(v)
        else if type:is_uint(typeof (v))
            => ::std::string::from_uint(v)
        else if type::( (typeof (v)) == bool)
            => if (v) == true =>
                str!{"true"}
            else
                str!{"false"}
        else if type::((typeof (v)) == void)
            => str!{"void"}
        else if type::((typeof (v)) == char)
            => ::std::string::from_char(v)
        else if type::((typeof (v)) == ::std::String)
            => (v)
        else if type::((typeof (v)) == &char)
            => ::std::string::init(v)
        else str! {nil}
    )
}

namespace std {
    type String: &char;

    namespace string {
        type StringData: struct {
            alloc: u64,
            size: u64,
            buff: char 'c[0]
        };

        fn init(value: String): ::std::String 
        {
            let str_data: &StringData;

            if value == nil {
                str_data = mem::alloc(sizeof StringData);
                str_data.alloc = 1;
                str_data.size = 0;
            }
            else {
                let v_len = c_str::strlen(value);
                str_data = mem::alloc(sizeof StringData + v_len + 1);
                str_data.alloc = v_len;
                str_data.size = v_len;
                
                c_str::copy(str_data.buff, value);
            }
            <- &(str_data.buff[0]);
        }

        fn init_sized(size: u64): ::std::String
        {
            let str_data: &StringData = mem::alloc(sizeof StringData + size + 1);
            str_data.alloc = size + 1;
            <- &(str_data.buff[0]);
        }

        fn free(str: std::String) 
        {
            mem::free(get_data(str));
        } 
        [exit_fn("free": std::String)]

        fn get_data(str: String): &StringData 
        {
            <- &(str: &StringData)[-1];
        }

        fn has_space(str_data: &StringData): bool
        {
            <- str_data.alloc > str_data.size + 1;
        }

        fn concat(dest: &String, src: String) 
        {
            let str_data = get_data(*dest);
            let str_len = size(*dest);
            let src_len = c_str::strlen(src);

            str_data.alloc = str_data.alloc + src_len;
            str_data.size = str_data.size + src_len;
            str_data = mem::realloc(str_data, sizeof StringData + str_data.alloc + 1);
            c_str::copy(&(str_data.buff[str_len]), src);

            str_data.buff[str_len + src_len] = '\0';
            *dest = &(str_data.buff[0]);
        }

        fn append(dest: &String, c: char)
        {
            let str_data = get_data(*dest);
            str_data.alloc++;
            str_data.size++;

            if(!has_space(str_data))
                str_data = mem::realloc(str_data, sizeof StringData + (str_data.alloc *= 2) + 1);
            str_data.buff[str_data.size - 1] = c;
            str_data.buff[str_data.size] = '\0';
            *dest = &(str_data.buff[0]);
        }

        fn copy(str: String): ::std::String 
        {   
            <- init(str);
        }

        fn contains(str: String, substr: String): bool 
        {
            <- c_str::strstr(str, substr) != nil;
        }

        # checks if a string contains a char
        fn contains_char(str: String, c: char): bool
        {
            if !str ret false;
            for let i: usize = 0; i < c_str::strlen(str); i++; {
                if str[i] == c ret true;
            }
            <- false;
        }

        # finds a char in a string and returns the index of the first found char
        fn find_char(str: String, c: char): std::Option
        {
            if !str ret none!();
            for let i: usize = 0; i < c_str::strlen(str); i++; {
                if str[i] == c ret some!(i);
            }
            <- none!();
        }

        fn split(str: String, delim: String): &::std::String {
            let str_vec = vec![String];
 
            let token: &char;
            while (token = c_str::strsep(&str, delim)) != nil {
                let part = init(token);
                vec_add!(str_vec, part);
            }
 
            <- str_vec;
        }

        fn size(str: String): u64 
        {
            <- c_str::strlen(str);
        }

        fn substr(str: ::std::String, from: i64, to: i64): ::std::String 
        {
            if to - from < 0 || to - from >= size(str)
                 ret nil;

            let ch_arr: &char = mem::alloc((to - from + 2) * sizeof char);
            for let i: i64 = from; i < to; i++; {
                ch_arr[i - from] = str[i];
            }
            #ch_arr[from - to] = '\0';
            
            let sub_str = init(ch_arr);
            mem::free(ch_arr);
            <- sub_str;
        }

        fn from_int(int: i64): ::std::String
        {
            let buf: char 'c[100];
            c_str::from_int(int, buf, 10);
            <- str!{buf};
        }

        fn from_uint(uint: u64): ::std::String
        {
            let buf: char 'c[100];
            c_str::from_uint(uint, buf, 10);
            <- str!{buf};
        }

        fn from_char(c: char): ::std::String
        {
            let buf: u16 = c << 8 | '\0';
            <- str!{&buf: &char};
        }

        fn format(fmt: const &char, args: ...): &void
            <- va_format(fmt, &args);

        fn va_format(fmt: const &char, args: &VAList): &void
        {
            let str = str!{};

            for ; (*fmt) != '\0'; fmt++; {
                if (*fmt) == '%' {
                    fmt++;
                    
                    let buf: char 'c[100];
                    match *fmt {
                        '%' => append(&str, *fmt);
                        'i' => {
                            c_str::from_int(va_arg!{*args, i32}, buf, 10);
                            concat(&str, buf);
                        }
                        'u' => {
                            c_str::from_uint(va_arg!{*args, u32}, buf, 10);
                            concat(&str, buf);
                        }
                        'o' => {
                            c_str::from_int(va_arg!{*args, i64}, buf, 8);
                            concat(&str, buf);
                        }
                        'x' => {
                            c_str::from_uint(va_arg!{*args, u64}, buf, 16);
                            concat(&str, buf);
                        }
                        'p' => { # pointer
                            c_str::from_uint(va_arg!{*args, &void}: u64, buf, 16);

                            concat(&str, "0x");
                            concat(&str, buf);
                        }
                        'c' => append(&str, va_arg!{*args, char}); # char
                        's' => concat(&str, va_arg!{*args, &char});
                        'n' => {
                            free(str);
                            <- str!{"\0"};
                        }
                        'e' => {
                            concat(&str, error::str(err));
                            
                            if error::error.msg {
                                append(&str, ' ');
                                concat(&str, error::error.msg);
                            }
                        }
                    }
                }
                else
                    append(&str, *fmt);
            }

            <- str;
        }
    }
} 