import "mem.csp";
import "types.csp";

# a macro to crate a string
macro str(chptr) {
    (::std::string::init(chptr))
}

# a macro to concatenate two strings
macro concat(a, b) {
    (::std::string::concat(&a, b))
}

# a macro to concatenate two strings
macro concat(a, b) {
    (::std::string::concat(&a, b))
}

namespace std {
    type String: &char;

    namespace string {
        type StringData: struct {
            alloc: u64,
            size: u64,
            buff: char[]
        };

        fn init(value: String): ::std::String 
        {
            let str_data: &StringData;

            if value == nil {
                str_data = mem::alloc(sizeof StringData);
                str_data.alloc = 1;
                str_data.size = 0;
            }
            else {
                let v_len = c_str::get_len(value);
                str_data = mem::alloc(sizeof StringData + v_len + 1);
                str_data.alloc = v_len;
                str_data.size = v_len;
                
                c_str::copy(str_data.buff, value);
            }
            <- &(str_data.buff[0]);
        }

        fn free(str: String) 
        {
            mem::free(get_data(str));
        } 

        fn get_data(str: String): &StringData 
        {
            <- &(str: &StringData)[-1];
        }

        fn concat(dest: &String, src: String) 
        {
            let str_data = get_data(*dest);

            str_data.alloc = str_data.alloc + c_str::get_len(src);
            str_data.size = str_data.size + c_str::get_len(src);
            str_data = mem::realloc(str_data, sizeof StringData + str_data.alloc + 1);

            c_str::copy(&(str_data.buff[c_str::get_len(*dest)]), src);

            *dest = &(str_data.buff[0]);
        }

        fn copy(str: String): ::std::String 
        {   
            <- init(str);
        }

        fn contains(str: String, substr: String): bool 
        {
            <- c_str::strstr(str, substr) != nil;
        }

       # fn split(str: String, delim: String): &::std::String {
       #     let str_vec = vec![String];
#
       #     let token: &char;
       #     while (token = ::strsep(&str, delim)) != nil {
       #         let part = init(token);
       #         vec_add!(str_vec, part);
       #     }
#
       #     <- str_vec;
       # }

        fn size(str: String): u64 
        {
            <- c_str::get_len(str);
        }

        fn substr(str: ::std::String, from: i64, to: i64): ::std::String 
        {
            if to - from < 0 || to - from >= size(str)
                 ret nil;

            let ch_arr: &char = mem::alloc((to - from + 2) * sizeof char);
            for let i: i64 = from; i < to; i++; {
                ch_arr[i - from] = str[i];
            }
            #ch_arr[from - to] = '\0';
            
            let sub_str = init(ch_arr);
            mem::free(ch_arr);
            <- sub_str;
        }
    }

    namespace c_str {
        # gets the length of a traditional C string without the null terminator
        fn get_len(str: const &char): usize
        {
            let length: usize = 0;
            while str[length] != nil length++;
            <- length;
        }

        # similar to c_str::copy
        fn copy(dest: &char, src: const &char)
        {
            mem::copy(dest, src, get_len(src) + 1);
        }

        fn strstr(str: &char, substr: &char): &char
        {
            let size: usize = get_len(substr);
            let ref = substr;

            while (*str) != 0 && (*ref) != 0 {
                if (*str)++ == (*ref) ref++;
                if (*ref) == 0 ret str - size;
                if (size == (ref - substr)) 
                    ref = substr;
            }

            <- nil;
        }

        fn strsep(stringp: &&char, delim: const &char): &char
        {
            let begin = *stringp;
            if begin == nil ret nil;

            let end: &char = begin + 0;#strspn(begin, delim);

            if (*end) != 0 {
                (*end)++;
                (*stringp) = end;
            }
            else
                (*stringp) = nil;
            
            <- begin;
        }
        
        # only works with unsigned character (u8)
        fn strspn(str: const &u8, chrs: const &u8): usize
        {
            let ta: u8[32];
            mem::zero(ta, sizeof typeof ta);
            let i: usize;
            for i = 0; chrs[i] != 0; i++;
                ta[chrs[i] >> 3] |= 0x1 << (chrs[i] % 8);
            for i = 0; (ta[str[i] >> 3] >> (str[i] % 8)) & 0x1; i++;
                noop;
            <- i;
        }
    }
}