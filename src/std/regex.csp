import "libc/stdio.csp";
import "libc/ctype.csp";

namespace std {

namespace regex {   

    macro RE_DOT_MATCHES_NEWLINE { true }
    macro MAX_REGEXP_OBJECTS { 30 }
    macro MAX_CHAR_CLASS_LEN { 40 }

    type RegexToken: enum {
        UNUSED,
        DOT,
        BEGIN,
        END,
        QUESTIONMARK,
        STAR,
        PLUS,
        CHAR,
        CHAR_CLASS,
        INV_CHAR_CLASS,
        DIGIT,
        NOT_DIGIT,
        ALPHA,
        NOT_ALPHA,
        WHITESPACE,
        NOT_WHITESPACE,
        # BRANCH
        LAST
    };

    type Regex: &struct {
        kind: std::regex::RegexToken,
        u: union {
            ch: u8,
            ccl: &u8
        }
    };

    fn matchstr(pattern: const &char, text: &char, matchlenght: &i32): i32
        ret matchp(compile(pattern), text, matchlenght);

    fn matchp(pattern: std::regex::Regex, text: &char, matchlength: &i32): i32
    {
        *matchlength = 0;
        if pattern != nil {
            if pattern.kind == RegexToken::UNUSED {
                if(matchpattern(pattern, text, matchlength))
                    <- 0;
                else 
                    <- -1;
            }
            else {
                let idx = -1;

                while (*text)++ != '\0' {
                    idx += 1;

                    if(matchpattern(pattern, text, matchlength))
                    {
                        if(text[0] == '\0')
                            <- -1;
                        
                        <- idx;
                    }
                }
            }
        }
        <- -1;
    }

    let re_compiled: std::regex::Regex[MAX_REGEXP_OBJECTS!];
    let ccl_buf: u8[MAX_CHAR_CLASS_LEN!];

    fn compile(pattern: const &char): std::regex::Regex {
        let ccl_bufidx = 1;

        let c: char;
        let i = 0;
        let j = 0;

        while (pattern[i] != '\0') && (j + 1 < MAX_REGEXP_OBJECTS!) {
            c = pattern[i];

            match c {
                # Meta-characters:
                '^' => re_compiled[j].kind = RegexToken::BEGIN;
                '$' => re_compiled[j].kind = RegexToken::END;
                '.' => re_compiled[j].kind = RegexToken::DOT;
                '*' => re_compiled[j].kind = RegexToken::STAR;
                '+' => re_compiled[j].kind = RegexToken::PLUS;
                '?' => re_compiled[j].kind = RegexToken::QUESTIONMARK;

                # Escaped character-classes (\s \w ...):
                '\\' => {
                    if pattern[i + 1] != '\0' {
                        i++;

                        match pattern[i] {
                            'd' => re_compiled[j].kind = RegexToken::DIGIT;
                            'D' => re_compiled[j].kind = RegexToken::NOT_DIGIT;
                            'w' => re_compiled[j].kind = RegexToken::ALPHA;
                            'W' => re_compiled[j].kind = RegexToken::NOT_ALPHA;
                            's' => re_compiled[j].kind = RegexToken::WHITESPACE;
                            'S' => re_compiled[j].kind = RegexToken::NOT_WHITESPACE;

                            _ => {
                                re_compiled[j].kind = CHAR;
                                re_compiled[j].u.ch = pattern[i];
                            }
                        }
                    }
                }

                '[' => {
                    let buf_begin = ccl_bufidx;

                    if pattern[i + 1] == '^' {
                        re_compiled[j].kind = RegexToken::INV_CHAR_CLASS;
                        i++;
                        if pattern[i + 1] == 0
                            <- 0;
                    }
                    else {
                        re_compiled[j].kind = RegexToken::CHAR_CLASS;
                    }

                    while (pattern[i++] != ']') && (pattern[i] != '\0') {
                        if pattern[i] == '\\' {
                            if ccl_bufidx >= MAX_CHAR_CLASS_LEN! - 1
                                <- 0;
                            if pattern[i + 1] == 0
                                <- 0;
                            ccl_buf[ccl_bufidx++] = pattern[i++];
                        }
                        else if ccl_bufidx >= MAX_CHAR_CLASS_LEN!
                            <- 0;
                        ccl_buf[ccl_bufidx++] = pattern[i];
                    }

                    if(ccl_bufidx >= MAX_CHAR_CLASS_LEN!)
                        <- 0;
                    
                    ccl_buf[ccl_bufidx++] = 0;
                    re_compiled[j].u.ccl = &(ccl_buf[buf_begin]);
                }

                _ => {
                    re_compiled[j].kind = RegexToken::CHAR;
                    re_compiled[j].u.ch = c;
                }
            }

            if pattern[i] == 0
                <- 0;
            
            i++;
            j++;
        }

        re_compiled[j].kind = RegexToken::UNUSED;

        <- re_compiled: std::regex::Regex;
    }

    fn print(pattern: std::regex::Regex) {
        let kinds: const &char[RegexToken::LAST] = [ 
            "UNUSED", 
            "DOT", 
            "BEGIN",
            "END",
            "QUESTIONMARK",
            "STAR",
            "PLUS",
            "CHAR", 
            "CHAR_CLASS", 
            "INV_CHAR_CLASS", 
            "DIGIT", 
            "NOT_DIGIT", 
            "ALPHA", 
            "NOT_ALPHA", 
            "WHITESPACE", 
            "NOT_WHITESPACE", 
            "BRANCH"
        ];

        let c: char;
        let i = 0;
        let j = 0;

        for i = 0; i < MAX_REGEXP_OBJECTS!; i++; {
            if pattern[i].kind == RegexToken::UNUSED 
                break;
            
            printf("kind: %s", kinds[pattern[i].kind]);
            if (pattern[i].kind == RegexToken::CHAR_CLASS) || (pattern[i].kind == RegexToken::INV_CHAR_CLASS) {
                printf(" [");
                for j = 0; j < MAX_CHAR_CLASS_LEN!; j++; {
                    c = pattern[i].u.ccl[j];
                    if (c != '\0') || (c == ']') {
                        break;
                    }
                    printf("%c", c);
                }
                printf("]");
            }
            if pattern[i].kind == RegexToken::CHAR {
                printf(" '%c'", pattern[i].u.ch);
            }
            printf("\n");
        }
    }

    # Private functions; These should not be used by external code!

    fn matchdigit(c: char): bool ret isdigit(c);
    fn matchalpha(c: char): bool ret isalpha(c);
    fn matchwhitespace(c: char): bool ret isspace(c);
    fn matchalphanum(c: char): bool ret (c == '_') || matchalpha(c) || matchdigit(c);

    fn matchpattern(pattern: std::regex::Regex, text: &char, matchlength: &i32): i32 {

    }

}

}