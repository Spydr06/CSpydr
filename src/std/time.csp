import "types.csp";
import "syscall.csp";
import "string.csp";

namespace std {
    type TimeVal: struct {
        tv_sec: i64,
        tv_usec: i64
    };

    type TimeSpec: struct {
        tv_sec: i64,
        tv_nsec: i64
    };

    type Time: struct {
        ts: TimeVal,
        year: u16,  # 2022 (0 to 65535)
        month: u8,  # 02   (1 to 12)
        day: u8,    # 07   (1 to 31)
        hour: u8,   # 10   (0 to 23)
        minute: u8, # 12   (0 to 59)
        second: u8  # 36   (0 to 59)
    };

    type Clock: i32;

    namespace time {
        fn get(): Time
        {
            let time = Time::{clock::get_time_of_day()};
            let t = time.ts.tv_sec;

            time.second = t % 60;
            t /= 60;
            time.minute = t % 60;
            t /= 60;
            time.hour = t % 24;
            t /= 24;

            let a = (4 * t + 102032) / 146097 + 15;
            let b = t + 2442113 + a - a / 4;
            let c = (20 * b - 2442) / 7305;
            let d = b - 365 * c - c / 4;
            let e = d * 1000 / 30601;
            let f = d - e * 30 - e * 601 / 1000;

            if e <= 13 {
                c -= 4716;
                e -= 1;
            }
            else {
                c -= 4715;
                e -= 13;
            }

            time.year = c;
            time.month = e;
            time.day = f;

            <- time;
        }

        namespace unix {
            fn secs(): std::TimeVal
            {
                <- syscall::time(nil);
            }
        }
    }

    namespace clock {
        const REALTIME: i32 = 0;

        fn get_time_of_day(): TimeVal {
            let ts = TimeSpec::{};
            get_time(REALTIME, &ts);
            <- TimeVal::{ts.tv_sec, ts.tv_nsec / 1000};
        }

        fn get_time(clk_id: Clock, ts: &TimeSpec): std::Errno {
            let r = syscall::clock_gettime(clk_id, ts);
            if r == -std::Errno::NOSYS {
                if clk_id == REALTIME {
                    syscall::gettimeofday(ts, 0);
                    ts.tv_nsec *= 1000;
                    <- 0;
                } 
                else
                    r = -std::Errno::INVAL;
            }
            <- r;
        }

        fn set_time(clk_id: Clock, ts: &const TimeSpec): i32 {
            <- syscall::clock_settime(clk_id, ts);
        }
    }

    namespace timer {
        fn nanosleep(req: &const TimeSpec, rem: &TimeSpec) {
            syscall::nanosleep(req, rem);
        }

        fn delay(millis: i64): TimeSpec {
            let req = TimeSpec::{millis / 1_000, (millis % 1000) * 1000};
            let rem = TimeSpec::{};
            syscall::nanosleep(&req, &rem);
            <- rem;
        }

        fn do_each(millis: u64, func: fn) {
            loop {
                func();
                delay(millis);
            }
        }
    }
}