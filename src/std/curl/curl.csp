#[**************************************************************************
 *                                  _   _ ____  _
 *  Project                     ___| | | |  _ \| |
 *                             / __| | | | |_) | |
 *                            | (__| |_| |  _ <| |___
 *                             \___|\___/|_| \_\_____|
 *
 * Copyright (C) 1998 - 2022, Daniel Stenberg, <daniel@haxx.se>, et al.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution. The terms
 * are also available at https://curl.se/docs/copyright.html.
 *
 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
 * copies of the Software, and permit persons to whom the Software is
 * furnished to do so, under the terms of the COPYING file.
 *
 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
 * KIND, either express or implied.
 *
 **************************************************************************]#

[link("curl")]

import "curl_system.csp";
import "curlver.csp";
import "types.csp";
import "system.csp";
import "multi.csp";
import "easy.csp";
import "urlapi.csp";
import "options.csp";

type CURL: void;
type CURLSH: void;

type curl_socket_t: i32;

macro CURL_SOCKET_BAD { (-1) }

type curl_sslbackend: enum {
    NONE = 0,
    OPENSSL = 1,
    GNUTLS = 2,
    NSS = 3,
    OBSOLETE4 = 4,  # Was QSOSSL.
    GSKIT = 5,
    POLARSSL = 6,
    WOLFSSL = 7,
    SCHANNEL = 8,
    SECURETRANSPORT = 9,
    AXTLS = 10, # never used since 7.63.0
    MBEDTLS = 11,
    MESALINK = 12,
    BEARSSL = 13,
    RUSTLS = 14
};

macro CURLSSLBACKEND_LIBRESSL { ::curl_sslbackend::OPENSSL }
macro CURLSSLBACKEND_BORINGSSL { ::curl_sslbackend::OPENSSL }
macro CURLSSLBACKEND_CYASSL { ::curl_sslbackend::WOLFSSL }
macro CURLSSLBACKEND_DARWINSSL { ::curl_sslbackend::SECURETRANSPORT }

type curl_httppost: struct {
    next: &curl_httppost,
    name: &char,
    namelength: i64,
    contents: &char,
    contentslength: i64,
    buffer: &char,
    bufferlength: i64,
    contenttype: &char,
    contentheader: &curl_slist,
    more: &curl_httppost,
    flags: i64,

macro CURL_HTTPPOST_FILENAME { (1 << 0) }
macro CURL_HTTPPOST_READFILE { (1 << 1) }
macro CURL_HTTPPOST_PTRNAME { (1 << 2) }
macro CURL_HTTPPOST_PTRCONTENTS { (1 << 3) }
macro CURL_HTTPPOST_BUFFER { (1 << 4) }
macro CURL_HTTPPOST_PTRBUFFER { (1 << 5) }
macro CURL_HTTPPOST_CALLBACK { (1 << 6) }
macro CURL_HTTPPOST_LARGE { (1 << 7) }

    showfilename: &char,
    userp: &void,
    contentlen: curl_off_t
};

macro CURL_PROGRESSFUNC_CONTINUE { 0x10000001 }

type curl_progress_callback: fn<i32>(&void, f64, f64, f64, f64);
type curl_xferinfo_callback: fn<i32>(&void, curl_off_t, curl_off_t, curl_off_t, curl_off_t);

macro CURL_MAX_READ_SIZE { 524288 }
macro CURL_MAX_WRITE_SIZE { 16384 }
macro CURL_MAX_HTTP_HEADER { (100*1024) }
macro CURL_WRITEFUNC_PAUSE { 0x10000001 }

type curl_write_callback: fn<u64>(&char, u64, u64, &void);
type curl_resolver_start_callback: fn<i32>(&void, &void, &void);

type curlfiletype: enum {
    FILE = 0,
    DIRECTORY,
    SYMLINK,
    DEVICE_BLOCK,
    DEVICE_CHAR,
    NAMEDPIPE,
    SOCKET,
    DOOR, # is possible only on Sun Solaris now

    UNKNOWN # should never occur
};

macro CURLFINFOFLAG_KNOWN_FILENAME   { (1<<0) }
macro CURLFINFOFLAG_KNOWN_FILETYPE   { (1<<1) }
macro CURLFINFOFLAG_KNOWN_TIME       { (1<<2) }
macro CURLFINFOFLAG_KNOWN_PERM       { (1<<3) }
macro CURLFINFOFLAG_KNOWN_UID        { (1<<4) }
macro CURLFINFOFLAG_KNOWN_GID        { (1<<5) }
macro CURLFINFOFLAG_KNOWN_SIZE       { (1<<6) }
macro CURLFINFOFLAG_KNOWN_HLINKCOUNT { (1<<7) }

type curl_fileinfo: struct {
    filename: &char,
    filetype: curlfiletype,
    time: std::time_t,
    perm: u32,
    uid: i32,
    gid: i32,
    size: curl_off_t,
    hardlinks: i64,

    strings: struct {
        time: &char,
        perm: &char,
        user: &char,
        group: &char,
        target: &char
    },

    flags: u32,
    b_data: &char,
    b_size: u64,
    b_used: u64
};

# return codes for CHUNK_BGN_FUNCTION
macro CURL_CHUNK_BGN_FUNC_OK     { 0 }
macro CURL_CHUNK_BGN_FUNC_FAIL   { 1 } # tell the lib to end the task
macro CURL_CHUNK_BGN_FUNC_SKIP   { 2 } # skip this chunk over

type curl_chunk_bgn_callback: fn<i64>(const &void, &void, i32);

# return codes for CHUNK_END_FUNCTION
macro CURL_CHUNK_END_FUNC_OK     { 0 }
macro CURL_CHUNK_END_FUNC_FAIL   { 1 } # tell the lib to end the task

type curl_chunk_end_callback: fn<i64>(&void);

# return codes for FNMATCHFUNCTION
macro CURL_FNMATCHFUNC_MATCH   { 0 } # string corresponds to the pattern
macro CURL_FNMATCHFUNC_NOMATCH { 1 } # pattern doesn't match the string
macro CURL_FNMATCHFUNC_FAIL    { 2 } # an error occurred

type curl_fnmatch_callback: fn<i32>(&void, const &char, const &char);

# These are the return codes for the seek callbacks
macro CURL_SEEKFUNC_OK       { 0 }
macro CURL_SEEKFUNC_FAIL     { 1 } # fail the entire transfer
macro CURL_SEEKFUNC_CANTSEEK { 2 } # tell libcurl seeking can't be done, so libcurl might try other means instead

type curl_seek_callback: fn<i32>(&void, curl_off_t, i32);

#[ This is a return code for the read callback that, when returned, will
   signal libcurl to immediately abort the current transfer. ]#
macro CURL_READFUNC_ABORT { 0x10000000 }
#[ This is a return code for the read callback that, when returned, will
   signal libcurl to pause sending data on the current transfer. ]#
macro CURL_READFUNC_PAUSE { 0x10000001 }

#[ Return code for when the trailing headers' callback has terminated
   without any errors]#
macro CURL_TRAILERFUNC_OK { 0 }
#[ Return code for when was an error in the trailing header's list and we
  want to abort the request ]#
macro CURL_TRAILERFUNC_ABORT { 1 }

type curl_read_callback: fn<u64>(&char, u64, u64, &void);
type curl_trailer_callback: fn<i32>(&&curl_slist, &void);

type curlsocktype: enum {
    IPCXN,  # socket created for a specific IP connection
    ACCEPT, # socket created by accept() call
    LAST    # never use
};

macro CURL_SOCKOPT_OK { 0 }
macro CURL_SOCKOPT_ERROR { 1 }
macro CURL_SOCKOPT_ALREADY_CONNECTED { 2 }

type curl_sockopt_callback: fn<i32>(&void, curl_socket_t, curlsocktype);

type curl_sockaddr: struct {
    family: i32,
    socktype: i32,
    protocol: i32,
    addrlen: u32,
    addr: std::SockAddr
};

type curl_opensocket_callback: fn<curl_socket_t>(&void, curlsocktype, &curl_sockaddr);
type curl_closesocket_callback: fn<i32>(&void, curl_socket_t);

type curlioerr: enum {
    OK,          # I/O operation successful
    UNKNOWNCMD,  # command was unknown to callback
    FAILRESTART, # failed to restart the read
    LAST         # never use
};

type curliocmd: enum {
    NOP,         # no operation
    RESTARTREAD, # restart the read stream from start
    LAST         # never use
};

type curl_ioctl_callback: fn<curlioerr>(&CURL, i32, &void);
type curl_malloc_callback: fn<&void>(u64);
type curl_free_callback: fn(&void);
type curl_realloc_callback: fn<&void>(&void, u64);
type curl_strdup_callback: fn<&char>(const &char);
type curl_calloc_callback: fn<&void>(u64, u64);

macro CURL_DID_MEMORY_FUNC_TYPEDEFS {}

type curl_infotype: enum {
    TEXT = 0,
    HEADER_IN,    # 1
    HEADER_OUT,   # 2
    DATA_IN,      # 3
    DATA_OUT,     # 4
    SSL_DATA_IN,  # 5
    SSL_DATA_OUT, # 6
    END
};

type curl_debug_callback: fn<i32>(&CURL, curl_infotype, &char, u64, &void);
type curl_prereq_callback: fn<i32>(&void, &char, &char, i32, i32);

macro CURL_PREREQFUNC_OK { 0 }
macro CURL_PREREQFUNC_ABORT { 1 }

type CURLcode: enum {
    OK = 0,
    UNSUPPORTED_PROTOCOL,    # 1
    FAILED_INIT,             # 2
    URL_MALFORMAT,           # 3
    NOT_BUILT_IN,            # 4 - [was obsoleted in August 2007 for 7.17.0, reused in April 2011 for 7.21.5]
    COULDNT_RESOLVE_PROXY,   # 5
    COULDNT_RESOLVE_HOST,    # 6
    COULDNT_CONNECT,         # 7
    WEIRD_SERVER_REPLY,      # 8
    REMOTE_ACCESS_DENIED,    # 9 a service was denied by the server due to lack of access - when login fails this is not returned.
    FTP_ACCEPT_FAILED,       # 10 - [was obsoleted in April 2006 for 7.15.4, reused in Dec 2011 for 7.24.0]
    FTP_WEIRD_PASS_REPLY,    # 11
    FTP_ACCEPT_TIMEOUT,      # 12 - timeout occurred accepting server [was obsoleted in August 2007 for 7.17.0, reused in Dec 2011 for 7.24.0]
    FTP_WEIRD_PASV_REPLY,    # 13
    FTP_WEIRD_227_FORMAT,    # 14
    FTP_CANT_GET_HOST,       # 15
    HTTP2,                   # 16 - A problem in the http2 framing layer. [was obsoleted in August 2007 for 7.17.0, reused in July 2014 for 7.38.0]
    FTP_COULDNT_SET_TYPE,    # 17
    PARTIAL_FILE,            # 18
    FTP_COULDNT_RETR_FILE,   # 19
    OBSOLETE20,              # 20 - NOT USED
    QUOTE_ERROR,             # 21 - quote command failure
    HTTP_RETURNED_ERROR,     # 22
    WRITE_ERROR,             # 23
    OBSOLETE24,              # 24 - NOT USED
    UPLOAD_FAILED,           # 25 - failed upload "command"
    READ_ERROR,              # 26 - couldn't open/read from file
    OUT_OF_MEMORY,           # 27
    OPERATION_TIMEDOUT,      # 28 - the timeout time was reached
    OBSOLETE29,              # 29 - NOT USED
    FTP_PORT_FAILED,         # 30 - FTP PORT operation failed
    FTP_COULDNT_USE_REST,    # 31 - the REST command failed
    OBSOLETE32,              # 32 - NOT USED
    RANGE_ERROR,             # 33 - RANGE "command" didn't work
    HTTP_POST_ERROR,         # 34
    SSL_CONNECT_ERROR,       # 35 - wrong when connecting with SSL
    BAD_DOWNLOAD_RESUME,     # 36 - couldn't resume download
    FILE_COULDNT_READ_FILE,  # 37
    LDAP_CANNOT_BIND,        # 38
    LDAP_SEARCH_FAILED,      # 39
    OBSOLETE40,              # 40 - NOT USED
    FUNCTION_NOT_FOUND,      # 41 - NOT USED starting with 7.53.0
    ABORTED_BY_CALLBACK,     # 42
    BAD_FUNCTION_ARGUMENT,   # 43
    OBSOLETE44,              # 44 - NOT USED
    INTERFACE_FAILED,        # 45 - INTERFACE failed
    OBSOLETE46,              # 46 - NOT USED
    TOO_MANY_REDIRECTS,      # 47 - catch endless re-direct loops
    UNKNOWN_OPTION,          # 48 - User specified an unknown option
    SETOPT_OPTION_SYNTAX,    # 49 - Malformed setopt option
    OBSOLETE50,              # 50 - NOT USED
    OBSOLETE51,              # 51 - NOT USED
    GOT_NOTHING,             # 52 - when this is a specific error
    SSL_ENGINE_NOTFOUND,     # 53 - SSL crypto engine not found
    SSL_ENGINE_SETFAILED,    # 54 - can not set SSL crypto engine as default
    SEND_ERROR,              # 55 - failed sending network data
    RECV_ERROR,              # 56 - failure in receiving network data
    OBSOLETE57,              # 57 - NOT IN USE
    SSL_CERTPROBLEM,         # 58 - problem with the local certificate
    SSL_CIPHER,              # 59 - couldn't use specified cipher
    PEER_FAILED_VERIFICATION, # 60 - peer's certificate or fingerprint wasn't verified fine
    BAD_CONTENT_ENCODING,    # 61 - Unrecognized/bad encoding
    OBSOLETE62,              # 62 - NOT IN USE since 7.82.0
    FILESIZE_EXCEEDED,       # 63 - Maximum file size exceeded
    USE_SSL_FAILED,          # 64 - Requested FTP SSL level failed
    SEND_FAIL_REWIND,        # 65 - Sending the data requires a rewind that failed
    SSL_ENGINE_INITFAILED,   # 66 - failed to initialise ENGINE
    LOGIN_DENIED,            # 67 - user, password or similar was not accepted and we failed to login
    TFTP_NOTFOUND,           # 68 - file not found on server
    TFTP_PERM,               # 69 - permission problem on server
    REMOTE_DISK_FULL,        # 70 - out of disk space on server
    TFTP_ILLEGAL,            # 71 - Illegal TFTP operation
    TFTP_UNKNOWNID,          # 72 - Unknown transfer ID
    REMOTE_FILE_EXISTS,      # 73 - File already exists
    TFTP_NOSUCHUSER,         # 74 - No such user
    CONV_FAILED,             # 75 - conversion failed
    OBSOLETE76,              # 76 - NOT IN USE since 7.82.0
    SSL_CACERT_BADFILE,      # 77 - could not load CACERT file, missing or wrong format
    REMOTE_FILE_NOT_FOUND,   # 78 - remote file not found
    SSH,                     # 79 - error from the SSH layer, somewhat generic so the error message will be of interest when this has happened

    SSL_SHUTDOWN_FAILED,     # 80 - Failed to shut down the SSL connection
    AGAIN,                   # 81 - socket is not ready for send/recv, wait till it's ready and try again (Added in 7.18.2)
    SSL_CRL_BADFILE,         # 82 - could not load CRL file, missing or wrong format (Added in 7.19.0)
    SSL_ISSUER_ERROR,        # 83 - Issuer check failed.  (Added in 7.19.0)
    FTP_PRET_FAILED,         # 84 - a PRET command failed
    RTSP_CSEQ_ERROR,         # 85 - mismatch of RTSP CSeq numbers
    RTSP_SESSION_ERROR,      # 86 - mismatch of RTSP Session Ids
    FTP_BAD_FILE_LIST,       # 87 - unable to parse FTP file list
    CHUNK_FAILED,            # 88 - chunk callback reported error
    NO_CONNECTION_AVAILABLE, # 89 - No connection available, the session will be queued
    SSL_PINNEDPUBKEYNOTMATCH, # 90 - specified pinned public key did not match
    SSL_INVALIDCERTSTATUS,   # 91 - invalid certificate status
    HTTP2_STREAM,            # 92 - stream error in HTTP/2 framing layer
                                     
    RECURSIVE_API_CALL,      # 93 - an api function was called from inside a callback
    AUTH_ERROR,              # 94 - an authentication function returned an error
    HTTP3,                   # 95 - An HTTP/3 layer problem
    QUIC_CONNECT_ERROR,      # 96 - QUIC connection error
    PROXY,                   # 97 - proxy handshake error
    SSL_CLIENTCERT,          # 98 - client-side certificate required
    LAST # never use!
};
#[
#ifndef CURL_NO_OLDIES # define this to test if your app builds with all the obsolete stuff removed! 

# Previously obsolete error code re-used in 7.38.0 
macro CURLE_OBSOLETE16 { CURLcode::HTTP2 }

# Previously obsolete error codes re-used in 7.24.0 
macro CURLE_OBSOLETE10 { CURLcode::FTP_ACCEPT_FAILED }
macro CURLE_OBSOLETE12 { CURLcode::FTP_ACCEPT_TIMEOUT }

#  compatibility with older names 
macro ENCODING ACCEPT_ENCODING
macro CURLE_FTP_WEIRD_SERVER_REPLY CURLE_WEIRD_SERVER_REPLY

# The following were added in 7.62.0 
macro CURLE_SSL_CACERT CURLE_PEER_FAILED_VERIFICATION

# The following were added in 7.21.5, April 2011 
macro CURLE_UNKNOWN_TELNET_OPTION CURLE_UNKNOWN_OPTION

# Added for 7.78.0 
macro CURLE_TELNET_OPTION_SYNTAX CURLE_SETOPT_OPTION_SYNTAX

# The following were added in 7.17.1 
# These are scheduled to disappear by 2009 
macro CURLE_SSL_PEER_CERTIFICATE CURLE_PEER_FAILED_VERIFICATION

# The following were added in 7.17.0 
# These are scheduled to disappear by 2009 
macro CURLE_OBSOLETE CURLE_OBSOLETE50 # no one should be using this! 
macro CURLE_BAD_PASSWORD_ENTERED CURLE_OBSOLETE46
macro CURLE_BAD_CALLING_ORDER CURLE_OBSOLETE44
macro CURLE_FTP_USER_PASSWORD_INCORRECT CURLE_OBSOLETE10
macro CURLE_FTP_CANT_RECONNECT CURLE_OBSOLETE16
macro CURLE_FTP_COULDNT_GET_SIZE CURLE_OBSOLETE32
macro CURLE_FTP_COULDNT_SET_ASCII CURLE_OBSOLETE29
macro CURLE_FTP_WEIRD_USER_REPLY CURLE_OBSOLETE12
macro CURLE_FTP_WRITE_ERROR CURLE_OBSOLETE20
macro CURLE_LIBRARY_NOT_FOUND CURLE_OBSOLETE40
macro CURLE_MALFORMAT_USER CURLE_OBSOLETE24
macro CURLE_SHARE_IN_USE CURLE_OBSOLETE57
macro CURLE_URL_MALFORMAT_USER CURLE_NOT_BUILT_IN

macro CURLE_FTP_ACCESS_DENIED CURLE_REMOTE_ACCESS_DENIED
macro CURLE_FTP_COULDNT_SET_BINARY CURLE_FTP_COULDNT_SET_TYPE
macro CURLE_FTP_QUOTE_ERROR CURLE_QUOTE_ERROR
macro CURLE_TFTP_DISKFULL CURLE_REMOTE_DISK_FULL
macro CURLE_TFTP_EXISTS CURLE_REMOTE_FILE_EXISTS
macro CURLE_HTTP_RANGE_ERROR CURLE_RANGE_ERROR
macro CURLE_FTP_SSL_FAILED CURLE_USE_SSL_FAILED

# The following were added earlier 

macro CURLE_OPERATION_TIMEOUTED CURLE_OPERATION_TIMEDOUT
macro CURLE_HTTP_NOT_FOUND CURLE_HTTP_RETURNED_ERROR
macro CURLE_HTTP_PORT_FAILED CURLE_INTERFACE_FAILED
macro CURLE_FTP_COULDNT_STOR_FILE CURLE_UPLOAD_FAILED
macro CURLE_FTP_PARTIAL_FILE CURLE_PARTIAL_FILE
macro CURLE_FTP_BAD_DOWNLOAD_RESUME CURLE_BAD_DOWNLOAD_RESUME
macro CURLE_LDAP_INVALID_URL CURLE_OBSOLETE62
macro CURLE_CONV_REQD CURLE_OBSOLETE76

# This was the error code 50 in 7.7.3 and a few earlier versions, this is no longer used by libcurl but is instead macrod here only to no make programs break 
macro CURLE_ALREADY_COMPLETE { 99999 }

# Provide defines for really old option names 
macro FILE WRITEDATA # name changed in 7.9.7 
macro INFILE READDATA # name changed in 7.9.7 
macro WRITEHEADER HEADERDATA

# Since long deprecated options with no code in the lib that does anything with them. 
macro WRITEINFO OBSOLETE40
macro CLOSEPOLICY OBSOLETE72]#

#
# TODO: this, multi.csp
#

type CURLproxycode: enum {
    CURLPX_OK,
    CURLPX_BAD_ADDRESS_TYPE,
    CURLPX_BAD_VERSION,
    CURLPX_CLOSED,
    CURLPX_GSSAPI,
    CURLPX_GSSAPI_PERMSG,
    CURLPX_GSSAPI_PROTECTION,
    CURLPX_IDENTD,
    CURLPX_IDENTD_DIFFER,
    CURLPX_LONG_HOSTNAME,
    CURLPX_LONG_PASSWD,
    CURLPX_LONG_USER,
    CURLPX_NO_AUTH,
    CURLPX_RECV_ADDRESS,
    CURLPX_RECV_AUTH,
    CURLPX_RECV_CONNECT,
    CURLPX_RECV_REQACK,
    CURLPX_REPLY_ADDRESS_TYPE_NOT_SUPPORTED,
    CURLPX_REPLY_COMMAND_NOT_SUPPORTED,
    CURLPX_REPLY_CONNECTION_REFUSED,
    CURLPX_REPLY_GENERAL_SERVER_FAILURE,
    CURLPX_REPLY_HOST_UNREACHABLE,
    CURLPX_REPLY_NETWORK_UNREACHABLE,
    CURLPX_REPLY_NOT_ALLOWED,
    CURLPX_REPLY_TTL_EXPIRED,
    CURLPX_REPLY_UNASSIGNED,
    CURLPX_REQUEST_FAILED,
    CURLPX_RESOLVE_HOST,
    CURLPX_SEND_AUTH,
    CURLPX_SEND_CONNECT,
    CURLPX_SEND_REQUEST,
    CURLPX_UNKNOWN_FAIL,
    CURLPX_UNKNOWN_MODE,
    CURLPX_USER_REJECTED,
    CURLPX_LAST # never use
};

type curl_conv_callback: fn<CURLcode>(&char, u64);
type curl_ssl_ctx_callback: fn<CURLcode>(&CURL, &void, &void);

type curl_proxytype: enum {
    CURLPROXY_HTTP = 0,   # added in 7.10, new in 7.19.4 default is to use CONNECT HTTP/1.1
    CURLPROXY_HTTP_1_0 = 1,   # added in 7.19.4, force to use CONNECT HTTP/1.0 
    CURLPROXY_HTTPS = 2, # added in 7.52.0
    CURLPROXY_SOCKS4 = 4, # support added in 7.15.2, enum existed already in 7.10
    CURLPROXY_SOCKS5 = 5, # added in 7.10
    CURLPROXY_SOCKS4A = 6, # added in 7.18.0
    CURLPROXY_SOCKS5_HOSTNAME = 7 # Use the SOCKS5 protocol but pass along the host name rather than the IP address. added in 7.18.0
}; # this enum was added in 7.10

macro CURLAUTH_NONE      { (0: u64) }
macro CURLAUTH_BASIC     { ((1: u64) << 0) }
macro CURLAUTH_DIGEST    { ((1: u64) << 1) }
macro CURLAUTH_NEGOTIATE { ((1: u64) << 2) }
# Deprecated since the advent of CURLAUTH_NEGOTIATE
macro CURLAUTH_GSSNEGOTIATE { CURLAUTH_NEGOTIATE! }
# Used for SOCKS5_AUTH to stay terminologically correct
macro CURLAUTH_GSSAPI { CURLAUTH_NEGOTIATE! }
macro CURLAUTH_NTLM   { ((1: u64) << 3) }
macro CURLAUTH_DIGEST_IE { ((1: u64) << 4) }
macro CURLAUTH_NTLM_WB { ((1: u64) << 5) }
macro CURLAUTH_BEARER { ((1: u64) << 6) }
macro CURLAUTH_AWS_SIGV4 { ((1: u64) << 7) }
macro CURLAUTH_ONLY { ((1: u64) << 31) }
macro CURLAUTH_ANY { (~CURLAUTH_DIGEST_IE!) }
macro CURLAUTH_ANYSAFE { (~(CURLAUTH_BASIC! | CURLAUTH_DIGEST_IE!)) }

macro CURLSSH_AUTH_ANY { (~0) }
macro CURLSSH_AUTH_NONE { 0 }
macro CURLSSH_AUTH_PUBLICKEY { (1 << 0) }
macro CURLSSH_AUTH_PASSWORD { (1 << 1) }
macro CURLSSH_AUTH_HOST { (1 << 2) }
macro CURLSSH_AUTH_KEYBOARD { (1 << 3) }
macro CURLSSH_AUTH_AGENT { (1 << 4) }
macro CURLSSH_AUTH_GSSAPI { (1 << 5) }
macro CURLSSH_AUTH_DEFAULT { CURLSSH_AUTH_ANY! }

macro CURLGSSAPI_DELEGATION_NONE { 0 }
macro CURLGSSAPI_DELEGATION_POLICY_FLAG { (1 << 0) }
macro CURLGSSAPI_DELEGATION_FLAG { (1 << 1) }

macro CURL_ERROR_SIZE { 256 }

type curl_khtype: enum {
    UNKNOWN,
    RSA1,
    RSA,
    DSS,
    ECDSA,
    ED25519
};

type curl_khkey: struct {
    key: const &char,
    lenght: u64,
    keytype: curl_khtype
};

type curl_khstat: enum {
    FINE_ADD_TO_FILE,
    FINE,
    REJECT,
    DEFER,
    FINE_REPLACE,
    LAST # never use
};

type curl_khmatch: enum {
    OK,
    MISMATCH,
    MISSING,
    LAST
};

type curl_sshkeycallback: fn<i32>(&CURL, const &curl_khkey, const &curl_khkey, curl_khmatch, &void);

type curl_usessl: enum {
    NONE,
    TRY,
    CONTROL,
    ALL,
    LAST # never use
};

macro CURLSSLOPT_ALLOW_BEAST { (1 << 0) }
macro CURLSSLOPT_NO_REVOKE { (1 << 1) }
macro CURLSSLOPT_NO_PARTIALCHAIN { (1 << 2) }
macro CURLSSLOPT_REVOKE_BEST_EFFORT { (1 << 3) }
macro CURLSSLOPT_NATIVE_CA { (1 << 4) }
macro CURLSSLOPT_AUTO_CLIENT_CERT { (1 << 5) }

macro CURL_HET_DEFAULT { (200: i64) }
macro CURL_UPKEEP_INTERVAL_DEFAULT { (60000: i64) }

type curl_ftpccc: enum {
    NONE,
    PASSIVE,
    ACTIVE,
    LAST # never use
};

type curl_ftpauth: enum {
    DEFAULT,
    SSL,
    TLS,
    LAST # never use
};

type curl_ftpcreatedir: enum {
    CREATE_DIR_NONE,
    CREATE_DIR,
    CREATE_DIR_RETRY,
    LAST # never use
};

type curl_ftpmethod: enum {
    DEFAULT,
    MULITCWD,
    NOCWD,
    SINGLECWD,
    LAST # never use
};

macro CURLHEADER_UNIFIED { 0 }
macro CURLHEADER_SEPERATE { (1 << 0) }

macro CURALTSVC_READONLYFILE { (1 << 2) }
macro CURALTSVC_H1 { (1 << 3) }
macro CURALTSVC_H2 { (1 << 4) }
macro CURALTSVC_H3 { (1 << 5) }

type curl_hstsentry: struct {
    name: &char,
    namelen: u64,
    include_subdomains: u8, # FIXME: should be bit-fielded to :1
    expire: char[18]
};

type curl_index: struct {
    index: u64,
    total: u64
};

type CURLSTScode: enum {
    OK,
    DONE,
    FAIL
};

type curl_hstsread_callback: fn<CURLSTScode>(&CURL, &curl_hstsentry, &void);
type curl_hstswrite_callback: fn<CURLSTScode>(&CURL, &curl_hstsentry, &curl_index, &void);

macro CURLHSTS_ENABLE { ((1 << 0): i64) }
macro CURLHSTS_READONLYFILE { ((1 << 1): i64) }

# CURLPROTO_ defines are for the *PROTOCOLS options
macro CURLPROTO_HTTP   { (1<<0) }
macro CURLPROTO_HTTPS  { (1<<1) }
macro CURLPROTO_FTP    { (1<<2) }
macro CURLPROTO_FTPS   { (1<<3) }
macro CURLPROTO_SCP    { (1<<4) }
macro CURLPROTO_SFTP   { (1<<5) }
macro CURLPROTO_TELNET { (1<<6) }
macro CURLPROTO_LDAP   { (1<<7) }
macro CURLPROTO_LDAPS  { (1<<8) }
macro CURLPROTO_DICT   { (1<<9) }
macro CURLPROTO_FILE   { (1<<10) }
macro CURLPROTO_TFTP   { (1<<11) }
macro CURLPROTO_IMAP   { (1<<12) }
macro CURLPROTO_IMAPS  { (1<<13) }
macro CURLPROTO_POP3   { (1<<14) }
macro CURLPROTO_POP3S  { (1<<15) }
macro CURLPROTO_SMTP   { (1<<16) }
macro CURLPROTO_SMTPS  { (1<<17) }
macro CURLPROTO_RTSP   { (1<<18) }
macro CURLPROTO_RTMP   { (1<<19) }
macro CURLPROTO_RTMPT  { (1<<20) }
macro CURLPROTO_RTMPE  { (1<<21) }
macro CURLPROTO_RTMPTE { (1<<22) }
macro CURLPROTO_RTMPS  { (1<<23) }
macro CURLPROTO_RTMPTS { (1<<24) }
macro CURLPROTO_GOPHER { (1<<25) }
macro CURLPROTO_SMB    { (1<<26) }
macro CURLPROTO_SMBS   { (1<<27) }
macro CURLPROTO_MQTT   { (1<<28) }
macro CURLPROTO_GOPHERS { (1<<29) }
macro CURLPROTO_ALL    { (~0) }# enable everything

macro CURLOPTTYPE_LONG          { 0 }
macro CURLOPTTYPE_OBJECTPOINT   { 10000 }
macro CURLOPTTYPE_FUNCTIONPOINT { 20000 }
macro CURLOPTTYPE_OFF_T         { 30000 }
macro CURLOPTTYPE_BLOB          { 40000 }

macro CURLOPT(na, t, nu) { 
    na = t + nu
}

# CURLOPT aliases that make no run-time difference

# 'char *' argument to a string with a trailing zero
macro CURLOPTTYPE_STRINGPOINT { 10000 }

# 'struct curl_slist *' argument
macro CURLOPTTYPE_SLISTPOINT  { 10000 }

# 'void *' argument passed untouched to callback
macro CURLOPTTYPE_CBPOINT     { 10000 }

# 'long' argument with a set of values/bitmask
macro CURLOPTTYPE_VALUES      { 0 }

type CURLoption: enum {
    #WRITEDATA = 10001,
    #URL = 10002,
    # ...
    #WRITEFUNCTION = 20011,

    # This is the FILE * or void * the regular output should be written to.
    CURLOPT!(WRITEDATA, CURLOPTTYPE_CBPOINT!, 1),

    # The full URL to get/put
    CURLOPT!(URL, CURLOPTTYPE_STRINGPOINT!, 2),

    # Port number to connect to, if other than default.
    CURLOPT!(PORT, CURLOPTTYPE_LONG!, 3),

    # Name of proxy to use.
    CURLOPT!(PROXY, CURLOPTTYPE_STRINGPOINT!, 4),

    # "user:password;options" to use when fetching.
    CURLOPT!(USERPWD, CURLOPTTYPE_STRINGPOINT!, 5),

    # "user:password" to use with proxy.
    CURLOPT!(PROXYUSERPWD, CURLOPTTYPE_STRINGPOINT!, 6),

    # Range to get, specified as an ASCII string.
    CURLOPT!(RANGE, CURLOPTTYPE_STRINGPOINT!, 7),

    # not used

    # Specified file stream to upload from (use as input):
    CURLOPT!(READDATA, CURLOPTTYPE_CBPOINT!, 9),

    # Buffer to receive error messages in, must be at least CURL_ERROR_SIZE bytes big.
    CURLOPT!(ERRORBUFFER, CURLOPTTYPE_OBJECTPOINT!, 10),

    # Function that will be called to store the output (instead of fwrite). The parameters will use fwrite() syntax, make sure to follow them.
    CURLOPT!(WRITEFUNCTION, CURLOPTTYPE_FUNCTIONPOINT!, 11),

    # Function that will be called to read the input (instead of fread). The parameters will use fread() syntax, make sure to follow them.
    CURLOPT!(READFUNCTION, CURLOPTTYPE_FUNCTIONPOINT!, 12),

    # Time-out the read operation after this amount of seconds
    CURLOPT!(TIMEOUT, CURLOPTTYPE_LONG!, 13),

    #[ If the INFILE is used, this can be used to inform libcurl about
     * how large the file being sent really is. That allows better error
     * checking and better verifies that the upload was successful. -1 means
     * unknown size.
     *
     * For large file support, there is also a _LARGE version of the key
     * which takes an off_t type, allowing platforms with larger off_t
     * sizes to handle larger files.  See below for INFILESIZE_LARGE.
      ]#
    
    CURLOPT!(INFILESIZE, CURLOPTTYPE_LONG!, 14),

    # POST static input fields.
    CURLOPT!(POSTFIELDS, CURLOPTTYPE_OBJECTPOINT!, 15),

    # Set the referrer page (needed by some CGIs)
    CURLOPT!(REFERER, CURLOPTTYPE_STRINGPOINT!, 16),

    # Set the FTP PORT string (interface name, named or numerical IP address) Use i.e '-' to use default address.
    CURLOPT!(FTPPORT, CURLOPTTYPE_STRINGPOINT!, 17),

    # Set the User-Agent string (examined by some CGIs)
    CURLOPT!(USERAGENT, CURLOPTTYPE_STRINGPOINT!, 18),

    #[ If the download receives less than "low speed limit" bytes/second
     * during "low speed time" seconds, the operations is aborted.
     * You could i.e if you have a pretty high speed connection, abort if
     * it is less than 2000 bytes/sec during 20 seconds.
    ]#

    # Set the "low speed limit"
    CURLOPT!(LOW_SPEED_LIMIT, CURLOPTTYPE_LONG!, 19),

    # Set the "low speed time"
    CURLOPT!(LOW_SPEED_TIME, CURLOPTTYPE_LONG!, 20),

    #[ Set the continuation offset.
     *
     * Note there is also a _LARGE version of this key which uses
     * off_t types, allowing for large file offsets on platforms which
     * use larger-than-32-bit off_t's.  Look below for RESUME_FROM_LARGE.
    ]#
    CURLOPT!(RESUME_FROM, CURLOPTTYPE_LONG!, 21),

    # Set cookie in request:
    CURLOPT!(COOKIE, CURLOPTTYPE_STRINGPOINT!, 22),

    # This points to a linked list of headers, struct curl_slist kind. This list is also used for RTSP (in spite of its name)
    CURLOPT!(HTTPHEADER, CURLOPTTYPE_SLISTPOINT!, 23),

    # This points to a linked list of post entries, struct curl_httppost
    CURLOPT!(HTTPPOST, CURLOPTTYPE_OBJECTPOINT!, 24),

    # name of the file keeping your private SSL-certificate
    CURLOPT!(SSLCERT, CURLOPTTYPE_STRINGPOINT!, 25),

    # password for the SSL or SSH private key
    CURLOPT!(KEYPASSWD, CURLOPTTYPE_STRINGPOINT!, 26),

    # send TYPE parameter?
    CURLOPT!(CRLF, CURLOPTTYPE_LONG!, 27),

    # send linked-list of QUOTE commands
    CURLOPT!(QUOTE, CURLOPTTYPE_SLISTPOINT!, 28),

    # send FILE * or void * to store headers to, if you use a callback it is simply passed to the callback unmodified
    CURLOPT!(HEADERDATA, CURLOPTTYPE_CBPOINT!, 29),

    # point to a file to read the initial cookies from, also enables "cookie awareness"
    CURLOPT!(COOKIEFILE, CURLOPTTYPE_STRINGPOINT!, 31),

    # What version to specifically try to use. See CURL_SSLVERSION defines below.
    CURLOPT!(SSLVERSION, CURLOPTTYPE_VALUES!, 32),

    # What kind of HTTP time condition to use, see defines
    CURLOPT!(TIMECONDITION, CURLOPTTYPE_VALUES!, 33),

    # Time to use with the above condition. Specified in number of seconds since 1 Jan 1970
    CURLOPT!(TIMEVALUE, CURLOPTTYPE_LONG!, 34),

    # 35 = OBSOLETE

    #[ Custom request, for customizing the get command like
       HTTP: DELETE, TRACE and others
       FTP: to use a different list command
    ]#
    CURLOPT!(CUSTOMREQUEST, CURLOPTTYPE_STRINGPOINT!, 36),

    # FILE handle to use instead of stderr
    CURLOPT!(STDERR, CURLOPTTYPE_OBJECTPOINT!, 37),

    # 38 is not used

    # send linked-list of post-transfer QUOTE commands
    CURLOPT!(POSTQUOTE, CURLOPTTYPE_SLISTPOINT!, 39),

     # OBSOLETE, do not use!
    CURLOPT!(OBSOLETE40, CURLOPTTYPE_OBJECTPOINT!, 40),

    # talk a lot
    CURLOPT!(VERBOSE, CURLOPTTYPE_LONG!, 41),

    # throw the header out too
    CURLOPT!(HEADER, CURLOPTTYPE_LONG!, 42),

    # shut off the progress meter
    CURLOPT!(NOPROGRESS, CURLOPTTYPE_LONG!, 43),

    # use HEAD to get http document
    CURLOPT!(NOBODY, CURLOPTTYPE_LONG!, 44),

    # no output on http error codes >= 400
    CURLOPT!(FAILONERROR, CURLOPTTYPE_LONG!, 45),

    # this is an upload
    CURLOPT!(UPLOAD, CURLOPTTYPE_LONG!, 46),

    # HTTP POST method
    CURLOPT!(POST, CURLOPTTYPE_LONG!, 47),

    # bare names when listing directories
    CURLOPT!(DIRLISTONLY, CURLOPTTYPE_LONG!, 48),

    # Append instead of overwrite on upload!
    CURLOPT!(APPEND, CURLOPTTYPE_LONG!, 50),

    # Specify whether to read the user+password from the .netrc or the URL. This must be one of the CURL_NETRC_* enums below.
    CURLOPT!(NETRC, CURLOPTTYPE_VALUES!, 51),

    # use Location: Luke!
    CURLOPT!(FOLLOWLOCATION, CURLOPTTYPE_LONG!, 52),

     # transfer data in text/ASCII format
    CURLOPT!(TRANSFERTEXT, CURLOPTTYPE_LONG!, 53),

    # HTTP PUT
    CURLOPT!(PUT, CURLOPTTYPE_LONG!, 54),

    # 55 = OBSOLETE

    #[ DEPRECATED
     * Function that will be called instead of the internal progress display
     * function. This function should be defined as the curl_progress_callback
     * prototype defines.
    ]#
    CURLOPT!(PROGRESSFUNCTION, CURLOPTTYPE_FUNCTIONPOINT!, 56),

    # Data passed to the PROGRESSFUNCTION and XFERINFOFUNCTION callbacks
    CURLOPT!(XFERINFODATA, CURLOPTTYPE_CBPOINT!, 57),

    # We want the referrer field set automatically when following locations
    CURLOPT!(AUTOREFERER, CURLOPTTYPE_LONG!, 58),

    # Port of the proxy, can be set in the proxy string as well with: "[host]:[port]"
    CURLOPT!(PROXYPORT, CURLOPTTYPE_LONG!, 59),

    # size of the POST input data, if strlen() is not good to use
    CURLOPT!(POSTFIELDSIZE, CURLOPTTYPE_LONG!, 60),

    # tunnel non-http operations through a HTTP proxy
    CURLOPT!(HTTPPROXYTUNNEL, CURLOPTTYPE_LONG!, 61),

    # Set the interface string to use as outgoing network interface
    CURLOPT!(INTERFACE, CURLOPTTYPE_STRINGPOINT!, 62),

    #[ Set the krb4/5 security level, this also enables krb4/5 awareness.  This
     * is a string, 'clear', 'safe', 'confidential' or 'private'.  If the string
     * is set but doesn't match one of these, 'private' will be used. 
    ]#
    CURLOPT!(KRBLEVEL, CURLOPTTYPE_STRINGPOINT!, 63),

    # Set if we should verify the peer in ssl handshake, set 1 to verify.
    CURLOPT!(SSL_VERIFYPEER, CURLOPTTYPE_LONG!, 64),

    # The CApath or CAfile used to validate the peer certificate this option is used only if SSL_VERIFYPEER is true
    CURLOPT!(CAINFO, CURLOPTTYPE_STRINGPOINT!, 65),

    # 66 = OBSOLETE
    # 67 = OBSOLETE

    # Maximum number of http redirects to follow
    CURLOPT!(MAXREDIRS, CURLOPTTYPE_LONG!, 68),

    # Pass a long set to 1 to get the date of the requested document (if possible)! Pass a zero to shut it off.
    CURLOPT!(FILETIME, CURLOPTTYPE_LONG!, 69),

    # This points to a linked list of telnet options
    CURLOPT!(TELNETOPTIONS, CURLOPTTYPE_SLISTPOINT!, 70),

    # Max amount of cached alive connections
    CURLOPT!(MAXCONNECTS, CURLOPTTYPE_LONG!, 71),

    # OBSOLETE, do not use!
    CURLOPT!(OBSOLETE72, CURLOPTTYPE_LONG!, 72),

    # 73 = OBSOLETE

    #[ Set to explicitly use a new connection for the upcoming transfer.
       Do not use this unless you're absolutely sure of this, as it makes the
       operation slower and is less friendly for the network.
    ]#
    CURLOPT!(FRESH_CONNECT, CURLOPTTYPE_LONG!, 74),

    #[ Set to explicitly forbid the upcoming transfer's connection to be re-used
       when done. Do not use this unless you're absolutely sure of this, as it
       makes the operation slower and is less friendly for the network.
    ]#
    CURLOPT!(FORBID_REUSE, CURLOPTTYPE_LONG!, 75),

    # Set to a file name that contains random data for libcurl to use to seed the random engine when doing SSL connects.
    CURLOPT!(RANDOM_FILE, CURLOPTTYPE_STRINGPOINT!, 76),

    # Set to the Entropy Gathering Daemon socket pathname
    CURLOPT!(EGDSOCKET, CURLOPTTYPE_STRINGPOINT!, 77),

    # Time-out connect operations after this amount of seconds, if connects are OK within this time, then fine... This only aborts the connect phase.
    CURLOPT!(CONNECTTIMEOUT, CURLOPTTYPE_LONG!, 78),

    # Function that will be called to store headers (instead of fwrite). The * parameters will use fwrite() syntax, make sure to follow them.
    CURLOPT!(HEADERFUNCTION, CURLOPTTYPE_FUNCTIONPOINT!, 79),

    # Set this to force the HTTP request to get back to GET. Only really usable if POST, PUT or a custom request have been used first.
    CURLOPT!(HTTPGET, CURLOPTTYPE_LONG!, 80),

    #[ Set if we should verify the Common name from the peer certificate in ssl
     * handshake, set 1 to check existence, 2 to ensure that it matches the
     * provided hostname.
    ]#
    CURLOPT!(SSL_VERIFYHOST, CURLOPTTYPE_LONG!, 81),

    # Specify which file name to write all known cookies in after completed operation. Set file name to "-" (dash) to make it go to stdout.
    CURLOPT!(COOKIEJAR, CURLOPTTYPE_STRINGPOINT!, 82),

    # Specify which SSL ciphers to use
    CURLOPT!(SSL_CIPHER_LIST, CURLOPTTYPE_STRINGPOINT!, 83),

    # Specify which HTTP version to use! This must be set to one of the CURL_HTTP_VERSION* enums set below.
    CURLOPT!(HTTP_VERSION, CURLOPTTYPE_VALUES!, 84),

    #[ Specifically switch on or off the FTP engine's use of the EPSV command. By
       default, that one will always be attempted before the more traditional
       PASV command.
    ]#
    CURLOPT!(FTP_USE_EPSV, CURLOPTTYPE_LONG!, 85),

    # type of the file keeping your SSL-certificate ("DER", "PEM", "ENG")
    CURLOPT!(SSLCERTTYPE, CURLOPTTYPE_STRINGPOINT!, 86),

    # name of the file keeping your private SSL-key
    CURLOPT!(SSLKEY, CURLOPTTYPE_STRINGPOINT!, 87),

    # type of the file keeping your private SSL-key ("DER", "PEM", "ENG")
    CURLOPT!(SSLKEYTYPE, CURLOPTTYPE_STRINGPOINT!, 88),

    # crypto engine for the SSL-sub system
    CURLOPT!(SSLENGINE, CURLOPTTYPE_STRINGPOINT!, 89),

    # set the crypto engine for the SSL-sub system as default the param has no meaning...
    
    CURLOPT!(SSLENGINE_DEFAULT, CURLOPTTYPE_LONG!, 90),

    # Non-zero value means to use the global dns cache
    # DEPRECATED, do not use!
    CURLOPT!(DNS_USE_GLOBAL_CACHE, CURLOPTTYPE_LONG!, 91),

    # DNS cache timeout
    CURLOPT!(DNS_CACHE_TIMEOUT, CURLOPTTYPE_LONG!, 92),

    # send linked-list of pre-transfer QUOTE commands
    CURLOPT!(PREQUOTE, CURLOPTTYPE_SLISTPOINT!, 93),

    # set the debug function
    CURLOPT!(DEBUGFUNCTION, CURLOPTTYPE_FUNCTIONPOINT!, 94),

    # set the data for the debug function
    CURLOPT!(DEBUGDATA, CURLOPTTYPE_CBPOINT!, 95),

    # mark this as start of a cookie session
    CURLOPT!(COOKIESESSION, CURLOPTTYPE_LONG!, 96),

    # The CApath directory used to validate the peer certificate this option is used only if SSL_VERIFYPEER is true
    CURLOPT!(CAPATH, CURLOPTTYPE_STRINGPOINT!, 97),

    # Instruct libcurl to use a smaller receive buffer
    CURLOPT!(BUFFERSIZE, CURLOPTTYPE_LONG!, 98),

    #[ Instruct libcurl to not use any signal/alarm handlers, even when using
       timeouts. This option is useful for multi-threaded applications.
       See libcurl-the-guide for more background information.
    ]#
    CURLOPT!(NOSIGNAL, CURLOPTTYPE_LONG!, 99),

    # Provide a CURLShare for mutexing non-ts data
    CURLOPT!(SHARE, CURLOPTTYPE_OBJECTPOINT!, 100),

    #[ indicates type of proxy. accepted values are CURLPROXY_HTTP (default),
       CURLPROXY_HTTPS, CURLPROXY_SOCKS4, CURLPROXY_SOCKS4A and
       CURLPROXY_SOCKS5.
    ]#
    CURLOPT!(PROXYTYPE, CURLOPTTYPE_VALUES!, 101),

    #[ Set the Accept-Encoding string. Use this to tell a server you would like
       the response to be compressed. Before 7.21.6, this was known as
       ENCODING
    ]#
    CURLOPT!(ACCEPT_ENCODING, CURLOPTTYPE_STRINGPOINT!, 102),

    # Set pointer to private data
    CURLOPT!(PRIVATE, CURLOPTTYPE_OBJECTPOINT!, 103),

    # Set aliases for HTTP 200 in the HTTP Response header
    CURLOPT!(HTTP200ALIASES, CURLOPTTYPE_SLISTPOINT!, 104),

    #[ Continue to send authentication (user+password) when following locations,
       even when hostname changed. This can potentially send off the name
       and password to whatever host the server decides.
    ]#
    CURLOPT!(UNRESTRICTED_AUTH, CURLOPTTYPE_LONG!, 105),

    #[ Specifically switch on or off the FTP engine's use of the EPRT command (
       it also disables the LPRT attempt). By default, those ones will always be
       attempted before the good old traditional PORT command.
    ]#
    CURLOPT!(FTP_USE_EPRT, CURLOPTTYPE_LONG!, 106),

    #[ Set this to a bitmask value to enable the particular authentications
       methods you like. Use this in combination with USERPWD.
       Note that setting multiple bits may cause extra network round-trips.
    ]#
    CURLOPT!(HTTPAUTH, CURLOPTTYPE_VALUES!, 107),

    #[ Set the ssl context callback function, currently only for OpenSSL or
       WolfSSL ssl_ctx, or mbedTLS mbedtls_ssl_config in the second argument.
       The function must match the curl_ssl_ctx_callback prototype.
    ]#
    CURLOPT!(SSL_CTX_FUNCTION, CURLOPTTYPE_FUNCTIONPOINT!, 108),

    # Set the userdata for the ssl context callback function's third argument
    CURLOPT!(SSL_CTX_DATA, CURLOPTTYPE_CBPOINT!, 109),

    #[ FTP Option that causes missing dirs to be created on the remote server.
       In 7.19.4 we introduced the convenience enums for this option using the
       CURLFTP_CREATE_DIR prefix.
    ]#
    CURLOPT!(FTP_CREATE_MISSING_DIRS, CURLOPTTYPE_LONG!, 110),

    #[ Set this to a bitmask value to enable the particular authentications
       methods you like. Use this in combination with PROXYUSERPWD.
       Note that setting multiple bits may cause extra network round-trips.
    ]#
    CURLOPT!(PROXYAUTH, CURLOPTTYPE_VALUES!, 111),

    #[ FTP option that changes the timeout, in seconds, associated with
       getting a response.  This is different from transfer timeout time and
       essentially places a demand on the FTP server to acknowledge commands
       in a timely manner.
    ]#
    CURLOPT!(FTP_RESPONSE_TIMEOUT, CURLOPTTYPE_LONG!, 112),

    #[ Set this option to one of the CURL_IPRESOLVE_* defines (see below) to
       tell libcurl to use those IP versions only. This only has effect on
       systems with support for more than one, i.e IPv4 _and_ IPv6.
    ]#
    CURLOPT!(IPRESOLVE, CURLOPTTYPE_VALUES!, 113),

    #[ Set this option to limit the size of a file that will be downloaded from
       an HTTP or FTP server.

       Note there is also _LARGE version which adds large file support for
       platforms which have larger off_t sizes.  See MAXFILESIZE_LARGE below.
    ]#
    CURLOPT!(MAXFILESIZE, CURLOPTTYPE_LONG!, 114),

    # See the comment for INFILESIZE above, but in short, specifies the size of the file being uploaded.  -1 means unknown.
    
    CURLOPT!(INFILESIZE_LARGE, CURLOPTTYPE_OFF_T!, 115),

    # Sets the continuation offset.  There is also a CURLOPTTYPE_LONG version of this; look above for RESUME_FROM.
    
    CURLOPT!(RESUME_FROM_LARGE, CURLOPTTYPE_OFF_T!, 116),

    # Sets the maximum size of data that will be downloaded from an HTTP or FTP server.  See MAXFILESIZE above for the LONG version.
    
    CURLOPT!(MAXFILESIZE_LARGE, CURLOPTTYPE_OFF_T!, 117),

    #[ Set this option to the file name of your .netrc file you want libcurl
       to parse (using the NETRC option). If not set, libcurl will do
       a poor attempt to find the user's home directory and check for a .netrc
       file in there.
    ]#
    CURLOPT!(NETRC_FILE, CURLOPTTYPE_STRINGPOINT!, 118),

    #[ Enable SSL/TLS for FTP, pick one of:
       CURLUSESSL_TRY     - try using SSL, proceed anyway otherwise
       CURLUSESSL_CONTROL - SSL for the control connection or fail
       CURLUSESSL_ALL     - SSL for all communication or fail
    ]#
    CURLOPT!(USE_SSL, CURLOPTTYPE_VALUES!, 119),

    # The _LARGE version of the standard POSTFIELDSIZE option
    CURLOPT!(POSTFIELDSIZE_LARGE, CURLOPTTYPE_OFF_T!, 120),

    # Enable/disable the TCP Nagle algorithm
    CURLOPT!(TCP_NODELAY, CURLOPTTYPE_LONG!, 121),

    # 122 OBSOLETE, used in 7.12.3. Gone in 7.13.0
    # 123 OBSOLETE. Gone in 7.16.0
    # 124 OBSOLETE, used in 7.12.3. Gone in 7.13.0
    # 125 OBSOLETE, used in 7.12.3. Gone in 7.13.0
    # 126 OBSOLETE, used in 7.12.3. Gone in 7.13.0
    # 127 OBSOLETE. Gone in 7.16.0
    # 128 OBSOLETE. Gone in 7.16.0

    #[ When FTP over SSL/TLS is selected (with USE_SSL), this option
       can be used to change libcurl's default action which is to first try
       "AUTH SSL" and then "AUTH TLS" in this order, and proceed when a OK
       response has been received.

       Available parameters are:
       CURLFTPAUTH_DEFAULT - let libcurl decide
       CURLFTPAUTH_SSL     - try "AUTH SSL" first, then TLS
       CURLFTPAUTH_TLS     - try "AUTH TLS" first, then SSL
    ]#
    CURLOPT!(FTPSSLAUTH, CURLOPTTYPE_VALUES!, 129),

    CURLOPT!(IOCTLFUNCTION, CURLOPTTYPE_FUNCTIONPOINT!, 130),
    CURLOPT!(IOCTLDATA, CURLOPTTYPE_CBPOINT!, 131),

    # 132 OBSOLETE. Gone in 7.16.0
    # 133 OBSOLETE. Gone in 7.16.0

    # null-terminated string for pass on to the FTP server when asked for "account" info
    CURLOPT!(FTP_ACCOUNT, CURLOPTTYPE_STRINGPOINT!, 134),

    # feed cookie into cookie engine
    CURLOPT!(COOKIELIST, CURLOPTTYPE_STRINGPOINT!, 135),

    # ignore Content-Length
    CURLOPT!(IGNORE_CONTENT_LENGTH, CURLOPTTYPE_LONG!, 136),

    #[ Set to non-zero to skip the IP address received in a 227 PASV FTP server
       response. Typically used for FTP-SSL purposes but is not restricted to
       that. libcurl will then instead use the same IP address it used for the
       control connection.
    ]#
    CURLOPT!(FTP_SKIP_PASV_IP, CURLOPTTYPE_LONG!, 137),

    # Select "file method" to use when doing FTP, see the curl_ftpmethod above.
    CURLOPT!(FTP_FILEMETHOD, CURLOPTTYPE_VALUES!, 138),

    # Local port number to bind the socket to
    CURLOPT!(LOCALPORT, CURLOPTTYPE_LONG!, 139),

    # Number of ports to try, including the first one set with LOCALPORT. Thus, setting it to 1 will make no additional attempts but the first.
    
    CURLOPT!(LOCALPORTRANGE, CURLOPTTYPE_LONG!, 140),

    # no transfer, set up connection and let application use the socket by extracting it with CURLINFO_LASTSOCKET
    CURLOPT!(CONNECT_ONLY, CURLOPTTYPE_LONG!, 141),

    # Function that will be called to convert from the network encoding (instead of using the iconv calls in libcurl)
    CURLOPT!(CONV_FROM_NETWORK_FUNCTION, CURLOPTTYPE_FUNCTIONPOINT!, 142),

    # Function that will be called to convert to the network encoding (instead of using the iconv calls in libcurl)
    CURLOPT!(CONV_TO_NETWORK_FUNCTION, CURLOPTTYPE_FUNCTIONPOINT!, 143),

    #[ Function that will be called to convert from UTF8
       (instead of using the iconv calls in libcurl)
       Note that this is used only for SSL certificate processing
    ]#
    CURLOPT!(CONV_FROM_UTF8_FUNCTION, CURLOPTTYPE_FUNCTIONPOINT!, 144),

    # if the connection proceeds too quickly then need to slow it down
    # limit-rate: maximum number of bytes per second to send or receive
    CURLOPT!(MAX_SEND_SPEED_LARGE, CURLOPTTYPE_OFF_T!, 145),
    CURLOPT!(MAX_RECV_SPEED_LARGE, CURLOPTTYPE_OFF_T!, 146),

    # Pointer to command string to send if USER/PASS fails.
    CURLOPT!(FTP_ALTERNATIVE_TO_USER, CURLOPTTYPE_STRINGPOINT!, 147),

    # callback function for setting socket options
    CURLOPT!(SOCKOPTFUNCTION, CURLOPTTYPE_FUNCTIONPOINT!, 148),
    CURLOPT!(SOCKOPTDATA, CURLOPTTYPE_CBPOINT!, 149),

    # set to 0 to disable session ID re-use for this transfer, default is enabled (== 1)
    CURLOPT!(SSL_SESSIONID_CACHE, CURLOPTTYPE_LONG!, 150),

    # allowed SSH authentication methods
    CURLOPT!(SSH_AUTH_TYPES, CURLOPTTYPE_VALUES!, 151),

    # Used by scp/sftp to do public/private key authentication
    CURLOPT!(SSH_PUBLIC_KEYFILE, CURLOPTTYPE_STRINGPOINT!, 152),
    CURLOPT!(SSH_PRIVATE_KEYFILE, CURLOPTTYPE_STRINGPOINT!, 153),

    # Send CCC (Clear Command Channel) after authentication
    CURLOPT!(FTP_SSL_CCC, CURLOPTTYPE_LONG!, 154),

    # Same as TIMEOUT and CONNECTTIMEOUT, but with ms resolution
    CURLOPT!(TIMEOUT_MS, CURLOPTTYPE_LONG!, 155),
    CURLOPT!(CONNECTTIMEOUT_MS, CURLOPTTYPE_LONG!, 156),

    # set to zero to disable the libcurl's decoding and thus pass the raw body data to the application even when it is encoded/compressed
    CURLOPT!(HTTP_TRANSFER_DECODING, CURLOPTTYPE_LONG!, 157),
    CURLOPT!(HTTP_CONTENT_DECODING, CURLOPTTYPE_LONG!, 158),

    # Permission used when creating new files and directories on the remote server for protocols that support it, SFTP/SCP/FILE
    CURLOPT!(NEW_FILE_PERMS, CURLOPTTYPE_LONG!, 159),
    CURLOPT!(NEW_DIRECTORY_PERMS, CURLOPTTYPE_LONG!, 160),

    # Set the behavior of POST when redirecting. Values must be set to one of CURL_REDIR* defines below. This used to be called POST301
    CURLOPT!(POSTREDIR, CURLOPTTYPE_VALUES!, 161),

    # used by scp/sftp to verify the host's public key
    CURLOPT!(SSH_HOST_PUBLIC_KEY_MD5, CURLOPTTYPE_STRINGPOINT!, 162),

    #[ Callback function for opening socket (instead of socket(2)). Optionally,
       callback is able change the address or refuse to connect returning
       CURL_SOCKET_BAD.  The callback should have type
       curl_opensocket_callback
    ]#
    CURLOPT!(OPENSOCKETFUNCTION, CURLOPTTYPE_FUNCTIONPOINT!, 163),
    CURLOPT!(OPENSOCKETDATA, CURLOPTTYPE_CBPOINT!, 164),

    # POST volatile input fields.
    CURLOPT!(COPYPOSTFIELDS, CURLOPTTYPE_OBJECTPOINT!, 165),

    # set transfer mode (;type=<a|i>) when doing FTP via an HTTP proxy
    CURLOPT!(PROXY_TRANSFER_MODE, CURLOPTTYPE_LONG!, 166),

    # Callback function for seeking in the input stream
    CURLOPT!(SEEKFUNCTION, CURLOPTTYPE_FUNCTIONPOINT!, 167),
    CURLOPT!(SEEKDATA, CURLOPTTYPE_CBPOINT!, 168),

    # CRL file
    CURLOPT!(CRLFILE, CURLOPTTYPE_STRINGPOINT!, 169),

    # Issuer certificate
    CURLOPT!(ISSUERCERT, CURLOPTTYPE_STRINGPOINT!, 170),

    # (IPv6) Address scope
    CURLOPT!(ADDRESS_SCOPE, CURLOPTTYPE_LONG!, 171),

    # Collect certificate chain info and allow it to get retrievable with CURLINFO_CERTINFO after the transfer is complete.
    CURLOPT!(CERTINFO, CURLOPTTYPE_LONG!, 172),

    # "name" and "pwd" to use when fetching.
    CURLOPT!(USERNAME, CURLOPTTYPE_STRINGPOINT!, 173),
    CURLOPT!(PASSWORD, CURLOPTTYPE_STRINGPOINT!, 174),

      # "name" and "pwd" to use with Proxy when fetching.
    CURLOPT!(PROXYUSERNAME, CURLOPTTYPE_STRINGPOINT!, 175),
    CURLOPT!(PROXYPASSWORD, CURLOPTTYPE_STRINGPOINT!, 176),

    #[ Comma separated list of hostnames defining no-proxy zones. These should
       match both hostnames directly, and hostnames within a domain. For
       example, local.com will match local.com and www.local.com, but NOT
       notlocal.com or www.notlocal.com. For compatibility with other
       implementations of this, .local.com will be considered to be the same as
       local.com. A single * is the only valid wildcard, and effectively
       disables the use of proxy.
    ]#
    CURLOPT!(NOPROXY, CURLOPTTYPE_STRINGPOINT!, 177),

    # block size for TFTP transfers
    CURLOPT!(TFTP_BLKSIZE, CURLOPTTYPE_LONG!, 178),

    # Socks Service
    # DEPRECATED, do not use!
    CURLOPT!(SOCKS5_GSSAPI_SERVICE, CURLOPTTYPE_STRINGPOINT!, 179),

    # Socks Service
    CURLOPT!(SOCKS5_GSSAPI_NEC, CURLOPTTYPE_LONG!, 180),

    #[ set the bitmask for the protocols that are allowed to be used for the
       transfer, which thus helps the app which takes URLs from users or other
       external inputs and want to restrict what protocol(s) to deal
       with. Defaults to CURLPROTO_ALL.
    ]#
    CURLOPT!(PROTOCOLS, CURLOPTTYPE_LONG!, 181),

    #[ set the bitmask for the protocols that libcurl is allowed to follow to,
       as a subset of the PROTOCOLS ones. That means the protocol needs
       to be set in both bitmasks to be allowed to get redirected to.
    ]#
    CURLOPT!(REDIR_PROTOCOLS, CURLOPTTYPE_LONG!, 182),

    # set the SSH knownhost file name to use
    CURLOPT!(SSH_KNOWNHOSTS, CURLOPTTYPE_STRINGPOINT!, 183),

    # set the SSH host key callback, must point to a curl_sshkeycallback function
    CURLOPT!(SSH_KEYFUNCTION, CURLOPTTYPE_FUNCTIONPOINT!, 184),

    # set the SSH host key callback custom pointer
    CURLOPT!(SSH_KEYDATA, CURLOPTTYPE_CBPOINT!, 185),

    # set the SMTP mail originator
    CURLOPT!(MAIL_FROM, CURLOPTTYPE_STRINGPOINT!, 186),

    # set the list of SMTP mail receiver(s)
    CURLOPT!(MAIL_RCPT, CURLOPTTYPE_SLISTPOINT!, 187),

    # FTP: send PRET before PASV
    CURLOPT!(FTP_USE_PRET, CURLOPTTYPE_LONG!, 188),

    # RTSP request method (OPTIONS, SETUP, PLAY, etc...)
    CURLOPT!(RTSP_REQUEST, CURLOPTTYPE_VALUES!, 189),

    # The RTSP session identifier
    CURLOPT!(RTSP_SESSION_ID, CURLOPTTYPE_STRINGPOINT!, 190),

    # The RTSP stream URI
    CURLOPT!(RTSP_STREAM_URI, CURLOPTTYPE_STRINGPOINT!, 191),

    # The Transport: header to use in RTSP requests
    CURLOPT!(RTSP_TRANSPORT, CURLOPTTYPE_STRINGPOINT!, 192),

    # Manually initialize the client RTSP CSeq for this handle
    CURLOPT!(RTSP_CLIENT_CSEQ, CURLOPTTYPE_LONG!, 193),

    # Manually initialize the server RTSP CSeq for this handle
    CURLOPT!(RTSP_SERVER_CSEQ, CURLOPTTYPE_LONG!, 194),

    # The stream to pass to INTERLEAVEFUNCTION.
    CURLOPT!(INTERLEAVEDATA, CURLOPTTYPE_CBPOINT!, 195),

    # Let the application define a custom write method for RTP data
    CURLOPT!(INTERLEAVEFUNCTION, CURLOPTTYPE_FUNCTIONPOINT!, 196),

    # Turn on wildcard matching
    CURLOPT!(WILDCARDMATCH, CURLOPTTYPE_LONG!, 197),

    # Directory matching callback called before downloading of an individual file (chunk) started
    CURLOPT!(CHUNK_BGN_FUNCTION, CURLOPTTYPE_FUNCTIONPOINT!, 198),

    # Directory matching callback called after the file (chunk) was downloaded, or skipped
    CURLOPT!(CHUNK_END_FUNCTION, CURLOPTTYPE_FUNCTIONPOINT!, 199),

    # Change match (fnmatch-like) callback for wildcard matching
    CURLOPT!(FNMATCH_FUNCTION, CURLOPTTYPE_FUNCTIONPOINT!, 200),

    # Let the application define custom chunk data pointer
    CURLOPT!(CHUNK_DATA, CURLOPTTYPE_CBPOINT!, 201),

    # FNMATCH_FUNCTION user pointer
    CURLOPT!(FNMATCH_DATA, CURLOPTTYPE_CBPOINT!, 202),

    # send linked-list of name:port:address sets
    CURLOPT!(RESOLVE, CURLOPTTYPE_SLISTPOINT!, 203),

    # Set a username for authenticated TLS
    CURLOPT!(TLSAUTH_USERNAME, CURLOPTTYPE_STRINGPOINT!, 204),

    # Set a password for authenticated TLS
    CURLOPT!(TLSAUTH_PASSWORD, CURLOPTTYPE_STRINGPOINT!, 205),

    # Set authentication type for authenticated TLS
    CURLOPT!(TLSAUTH_TYPE, CURLOPTTYPE_STRINGPOINT!, 206),

    #[ Set to 1 to enable the "TE:" header in HTTP requests to ask for
       compressed transfer-encoded responses. Set to 0 to disable the use of TE:
       in outgoing requests. The current default is 0, but it might change in a
       future libcurl release.

       libcurl will ask for the compressed methods it knows of, and if that
       isn't any, it will not ask for transfer-encoding at all even if this
       option is set to 1.
    ]#
    
    CURLOPT!(TRANSFER_ENCODING, CURLOPTTYPE_LONG!, 207),

    # Callback function for closing socket (instead of close(2)). The callback should have type curl_closesocket_callback
    CURLOPT!(CLOSESOCKETFUNCTION, CURLOPTTYPE_FUNCTIONPOINT!, 208),
    CURLOPT!(CLOSESOCKETDATA, CURLOPTTYPE_CBPOINT!, 209),

    # allow GSSAPI credential delegation
    CURLOPT!(GSSAPI_DELEGATION, CURLOPTTYPE_VALUES!, 210),

    # Set the name servers to use for DNS resolution
    CURLOPT!(DNS_SERVERS, CURLOPTTYPE_STRINGPOINT!, 211),

    # Time-out accept operations (currently for FTP only) after this amount of milliseconds.
    CURLOPT!(ACCEPTTIMEOUT_MS, CURLOPTTYPE_LONG!, 212),

    # Set TCP keepalive
    CURLOPT!(TCP_KEEPALIVE, CURLOPTTYPE_LONG!, 213),

    # non-universal keepalive knobs (Linux, AIX, HP-UX, more)
    CURLOPT!(TCP_KEEPIDLE, CURLOPTTYPE_LONG!, 214),
    CURLOPT!(TCP_KEEPINTVL, CURLOPTTYPE_LONG!, 215),

    # Enable/disable specific SSL features with a bitmask, see CURLSSLOPT_*
    CURLOPT!(SSL_OPTIONS, CURLOPTTYPE_VALUES!, 216),

    # Set the SMTP auth originator
    CURLOPT!(MAIL_AUTH, CURLOPTTYPE_STRINGPOINT!, 217),

    # Enable/disable SASL initial response
    CURLOPT!(SASL_IR, CURLOPTTYPE_LONG!, 218),

    #[ Function that will be called instead of the internal progress display
     * function. This function should be defined as the curl_xferinfo_callback
     * prototype defines. (Deprecates PROGRESSFUNCTION)
     ]#
    CURLOPT!(XFERINFOFUNCTION, CURLOPTTYPE_FUNCTIONPOINT!, 219),

    # The XOAUTH2 bearer token
    CURLOPT!(XOAUTH2_BEARER, CURLOPTTYPE_STRINGPOINT!, 220),

    #[ Set the interface string to use as outgoing network
     * interface for DNS requests.
     * Only supported by the c-ares DNS backend
     ]#
    CURLOPT!(DNS_INTERFACE, CURLOPTTYPE_STRINGPOINT!, 221),

    # Set the local IPv4 address to use for outgoing DNS requests. Only supported by the c-ares DNS backend
    CURLOPT!(DNS_LOCAL_IP4, CURLOPTTYPE_STRINGPOINT!, 222),

    # Set the local IPv6 address to use for outgoing DNS requests. Only supported by the c-ares DNS backend
    CURLOPT!(DNS_LOCAL_IP6, CURLOPTTYPE_STRINGPOINT!, 223),

    # Set authentication options directly
    CURLOPT!(LOGIN_OPTIONS, CURLOPTTYPE_STRINGPOINT!, 224),

    # Enable/disable TLS NPN extension (http2 over ssl might fail without)
    CURLOPT!(SSL_ENABLE_NPN, CURLOPTTYPE_LONG!, 225),

    # Enable/disable TLS ALPN extension (http2 over ssl might fail without)
    CURLOPT!(SSL_ENABLE_ALPN, CURLOPTTYPE_LONG!, 226),

    # Time to wait for a response to a HTTP request containing an Expect: 100-continue header before sending the data anyway.
    CURLOPT!(EXPECT_100_TIMEOUT_MS, CURLOPTTYPE_LONG!, 227),

    # This points to a linked list of headers used for proxy requests only, struct curl_slist kind
    CURLOPT!(PROXYHEADER, CURLOPTTYPE_SLISTPOINT!, 228),

    # Pass in a bitmask of "header options"
    CURLOPT!(HEADEROPT, CURLOPTTYPE_VALUES!, 229),

    # The public key in DER form used to validate the peer public key this option is used only if SSL_VERIFYPEER is true
    CURLOPT!(PINNEDPUBLICKEY, CURLOPTTYPE_STRINGPOINT!, 230),

    # Path to Unix domain socket
    CURLOPT!(UNIX_SOCKET_PATH, CURLOPTTYPE_STRINGPOINT!, 231),

    # Set if we should verify the certificate status.
    CURLOPT!(SSL_VERIFYSTATUS, CURLOPTTYPE_LONG!, 232),

    # Set if we should enable TLS false start.
    CURLOPT!(SSL_FALSESTART, CURLOPTTYPE_LONG!, 233),

    # Do not squash dot-dot sequences
    CURLOPT!(PATH_AS_IS, CURLOPTTYPE_LONG!, 234),

    # Proxy Service Name
    CURLOPT!(PROXY_SERVICE_NAME, CURLOPTTYPE_STRINGPOINT!, 235),

    # Service Name
    CURLOPT!(SERVICE_NAME, CURLOPTTYPE_STRINGPOINT!, 236),

    # Wait/don't wait for pipe/mutex to clarify
    CURLOPT!(PIPEWAIT, CURLOPTTYPE_LONG!, 237),

    # Set the protocol used when curl is given a URL without a protocol
    CURLOPT!(DEFAULT_PROTOCOL, CURLOPTTYPE_STRINGPOINT!, 238),

    # Set stream weight, 1 - 256 (default is 16)
    CURLOPT!(STREAM_WEIGHT, CURLOPTTYPE_LONG!, 239),

    # Set stream dependency on another CURL handle
    CURLOPT!(STREAM_DEPENDS, CURLOPTTYPE_OBJECTPOINT!, 240),

    # Set E-xclusive stream dependency on another CURL handle
    CURLOPT!(STREAM_DEPENDS_E, CURLOPTTYPE_OBJECTPOINT!, 241),

    # Do not send any tftp option requests to the server
    CURLOPT!(TFTP_NO_OPTIONS, CURLOPTTYPE_LONG!, 242),

    # Linked-list of host:port:connect-to-host:connect-to-port, overrides the URL's host:port (only for the network layer)
    CURLOPT!(CONNECT_TO, CURLOPTTYPE_SLISTPOINT!, 243),

    # Set TCP Fast Open
    CURLOPT!(TCP_FASTOPEN, CURLOPTTYPE_LONG!, 244),

    # Continue to send data if the server responds early with an HTTP status code >= 300
    CURLOPT!(KEEP_SENDING_ON_ERROR, CURLOPTTYPE_LONG!, 245),

    # The CApath or CAfile used to validate the proxy certificate this option is used only if PROXY_SSL_VERIFYPEER is true
    CURLOPT!(PROXY_CAINFO, CURLOPTTYPE_STRINGPOINT!, 246),

    # The CApath directory used to validate the proxy certificate this option is used only if PROXY_SSL_VERIFYPEER is true
    CURLOPT!(PROXY_CAPATH, CURLOPTTYPE_STRINGPOINT!, 247),

    # Set if we should verify the proxy in ssl handshake, set 1 to verify.
    CURLOPT!(PROXY_SSL_VERIFYPEER, CURLOPTTYPE_LONG!, 248),

    #[ Set if we should verify the Common name from the proxy certificate in ssl
     * handshake, set 1 to check existence, 2 to ensure that it matches
     * the provided hostname.
     ]#
    CURLOPT!(PROXY_SSL_VERIFYHOST, CURLOPTTYPE_LONG!, 249),

    # What version to specifically try to use for proxy. See CURL_SSLVERSION defines below.
    CURLOPT!(PROXY_SSLVERSION, CURLOPTTYPE_VALUES!, 250),

    # Set a username for authenticated TLS for proxy
    CURLOPT!(PROXY_TLSAUTH_USERNAME, CURLOPTTYPE_STRINGPOINT!, 251),

    # Set a password for authenticated TLS for proxy
    CURLOPT!(PROXY_TLSAUTH_PASSWORD, CURLOPTTYPE_STRINGPOINT!, 252),

    # Set authentication type for authenticated TLS for proxy
    CURLOPT!(PROXY_TLSAUTH_TYPE, CURLOPTTYPE_STRINGPOINT!, 253),

    # name of the file keeping your private SSL-certificate for proxy
    CURLOPT!(PROXY_SSLCERT, CURLOPTTYPE_STRINGPOINT!, 254),

    # type of the file keeping your SSL-certificate ("DER", "PEM", "ENG") for proxy
    CURLOPT!(PROXY_SSLCERTTYPE, CURLOPTTYPE_STRINGPOINT!, 255),

    # name of the file keeping your private SSL-key for proxy
    CURLOPT!(PROXY_SSLKEY, CURLOPTTYPE_STRINGPOINT!, 256),

    # type of the file keeping your private SSL-key ("DER", "PEM", "ENG") for proxy
    CURLOPT!(PROXY_SSLKEYTYPE, CURLOPTTYPE_STRINGPOINT!, 257),

    # password for the SSL private key for proxy
    CURLOPT!(PROXY_KEYPASSWD, CURLOPTTYPE_STRINGPOINT!, 258),

    # Specify which SSL ciphers to use for proxy
    CURLOPT!(PROXY_SSL_CIPHER_LIST, CURLOPTTYPE_STRINGPOINT!, 259),

    # CRL file for proxy
    CURLOPT!(PROXY_CRLFILE, CURLOPTTYPE_STRINGPOINT!, 260),

    # Enable/disable specific SSL features with a bitmask for proxy, see CURLSSLOPT_
    CURLOPT!(PROXY_SSL_OPTIONS, CURLOPTTYPE_LONG!, 261),

    # Name of pre proxy to use.
    CURLOPT!(PRE_PROXY, CURLOPTTYPE_STRINGPOINT!, 262),

    # The public key in DER form used to validate the proxy public key this option is used only if PROXY_SSL_VERIFYPEER is true
    CURLOPT!(PROXY_PINNEDPUBLICKEY, CURLOPTTYPE_STRINGPOINT!, 263),

    # Path to an abstract Unix domain socket
    CURLOPT!(ABSTRACT_UNIX_SOCKET, CURLOPTTYPE_STRINGPOINT!, 264),

    # Suppress proxy CONNECT response headers from user callbacks
    CURLOPT!(SUPPRESS_CONNECT_HEADERS, CURLOPTTYPE_LONG!, 265),

    # The request target, instead of extracted from the URL
    CURLOPT!(REQUEST_TARGET, CURLOPTTYPE_STRINGPOINT!, 266),

    # bitmask of allowed auth methods for connections to SOCKS5 proxies
    CURLOPT!(SOCKS5_AUTH, CURLOPTTYPE_LONG!, 267),

    # Enable/disable SSH compression
    CURLOPT!(SSH_COMPRESSION, CURLOPTTYPE_LONG!, 268),

    # Post MIME data.
    CURLOPT!(MIMEPOST, CURLOPTTYPE_OBJECTPOINT!, 269),

    # Time to use with the TIMECONDITION. Specified in number of seconds since 1 Jan 1970.
    CURLOPT!(TIMEVALUE_LARGE, CURLOPTTYPE_OFF_T!, 270),

    # Head start in milliseconds to give happy eyeballs.
    CURLOPT!(HAPPY_EYEBALLS_TIMEOUT_MS, CURLOPTTYPE_LONG!, 271),

    # Function that will be called before a resolver request is made
    CURLOPT!(RESOLVER_START_FUNCTION, CURLOPTTYPE_FUNCTIONPOINT!, 272),

    # User data to pass to the resolver start callback.
    CURLOPT!(RESOLVER_START_DATA, CURLOPTTYPE_CBPOINT!, 273),

    # send HAProxy PROXY protocol header?
    CURLOPT!(HAPROXYPROTOCOL, CURLOPTTYPE_LONG!, 274),

    # shuffle addresses before use when DNS returns multiple
    CURLOPT!(DNS_SHUFFLE_ADDRESSES, CURLOPTTYPE_LONG!, 275),

    # Specify which TLS 1.3 ciphers suites to use
    CURLOPT!(TLS13_CIPHERS, CURLOPTTYPE_STRINGPOINT!, 276),
    CURLOPT!(PROXY_TLS13_CIPHERS, CURLOPTTYPE_STRINGPOINT!, 277),

    # Disallow specifying username/login in URL.
    CURLOPT!(DISALLOW_USERNAME_IN_URL, CURLOPTTYPE_LONG!, 278),

    # DNS-over-HTTPS URL
    CURLOPT!(DOH_URL, CURLOPTTYPE_STRINGPOINT!, 279),

    # Preferred buffer size to use for uploads
    CURLOPT!(UPLOAD_BUFFERSIZE, CURLOPTTYPE_LONG!, 280),

    # Time in ms between connection upkeep calls for long-lived connections.
    CURLOPT!(UPKEEP_INTERVAL_MS, CURLOPTTYPE_LONG!, 281),

    # Specify URL using CURL URL API.
    CURLOPT!(CURLU, CURLOPTTYPE_OBJECTPOINT!, 282),

    # add trailing data just after no more data is available
    CURLOPT!(TRAILERFUNCTION, CURLOPTTYPE_FUNCTIONPOINT!, 283),

    # pointer to be passed to HTTP_TRAILER_FUNCTION
    CURLOPT!(TRAILERDATA, CURLOPTTYPE_CBPOINT!, 284),

    # set this to 1L to allow HTTP/0.9 responses or 0L to disallow
    CURLOPT!(HTTP09_ALLOWED, CURLOPTTYPE_LONG!, 285),

    # alt-svc control bitmask
    CURLOPT!(ALTSVC_CTRL, CURLOPTTYPE_LONG!, 286),

    # alt-svc cache file name to possibly read from/write to
    CURLOPT!(ALTSVC, CURLOPTTYPE_STRINGPOINT!, 287),

    # maximum age (idle time) of a connection to consider it for reuse (in seconds)
    CURLOPT!(MAXAGE_CONN, CURLOPTTYPE_LONG!, 288),

    # SASL authorisation identity
    CURLOPT!(SASL_AUTHZID, CURLOPTTYPE_STRINGPOINT!, 289),

    # allow RCPT TO command to fail for some recipients
    CURLOPT!(MAIL_RCPT_ALLLOWFAILS, CURLOPTTYPE_LONG!, 290),

    # the private SSL-certificate as a "blob"
    CURLOPT!(SSLCERT_BLOB, CURLOPTTYPE_BLOB!, 291),
    CURLOPT!(SSLKEY_BLOB, CURLOPTTYPE_BLOB!, 292),
    CURLOPT!(PROXY_SSLCERT_BLOB, CURLOPTTYPE_BLOB!, 293),
    CURLOPT!(PROXY_SSLKEY_BLOB, CURLOPTTYPE_BLOB!, 294),
    CURLOPT!(ISSUERCERT_BLOB, CURLOPTTYPE_BLOB!, 295),

    # Issuer certificate for proxy
    CURLOPT!(PROXY_ISSUERCERT, CURLOPTTYPE_STRINGPOINT!, 296),
    CURLOPT!(PROXY_ISSUERCERT_BLOB, CURLOPTTYPE_BLOB!, 297),

    #[ the EC curves requested by the TLS client (RFC 8422, 5.1);
     * OpenSSL support via 'set_groups'/'set_curves':
     * https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set1_groups.html
    ]#
    CURLOPT!(SSL_EC_CURVES, CURLOPTTYPE_STRINGPOINT!, 298),

    # HSTS bitmask
    CURLOPT!(HSTS_CTRL, CURLOPTTYPE_LONG!, 299),
    # HSTS file name
    CURLOPT!(HSTS, CURLOPTTYPE_STRINGPOINT!, 300),

    # HSTS read callback
    CURLOPT!(HSTSREADFUNCTION, CURLOPTTYPE_FUNCTIONPOINT!, 301),
    CURLOPT!(HSTSREADDATA, CURLOPTTYPE_CBPOINT!, 302),

    # HSTS write callback
    CURLOPT!(HSTSWRITEFUNCTION, CURLOPTTYPE_FUNCTIONPOINT!, 303),
    CURLOPT!(HSTSWRITEDATA, CURLOPTTYPE_CBPOINT!, 304),

    # Parameters for V4 signature
    CURLOPT!(AWS_SIGV4, CURLOPTTYPE_STRINGPOINT!, 305),

    # Same as SSL_VERIFYPEER but for DoH (DNS-over-HTTPS) servers.
    CURLOPT!(DOH_SSL_VERIFYPEER, CURLOPTTYPE_LONG!, 306),

    # Same as SSL_VERIFYHOST but for DoH (DNS-over-HTTPS) servers.
    CURLOPT!(DOH_SSL_VERIFYHOST, CURLOPTTYPE_LONG!, 307),

    # Same as SSL_VERIFYSTATUS but for DoH (DNS-over-HTTPS) servers.
    CURLOPT!(DOH_SSL_VERIFYSTATUS, CURLOPTTYPE_LONG!, 308),

    # The CA certificates as "blob" used to validate the peer certificate this option is used only if SSL_VERIFYPEER is true
    CURLOPT!(CAINFO_BLOB, CURLOPTTYPE_BLOB!, 309),

    # The CA certificates as "blob" used to validate the proxy certificate this option is used only if PROXY_SSL_VERIFYPEER is true
    CURLOPT!(PROXY_CAINFO_BLOB, CURLOPTTYPE_BLOB!, 310),

    # used by scp/sftp to verify the host's public key
    CURLOPT!(SSH_HOST_PUBLIC_KEY_SHA256, CURLOPTTYPE_STRINGPOINT!, 311),

    # Function that will be called immediately before the initial request is made on a connection (after any protocol negotiation step). 
    CURLOPT!(PREREQFUNCTION, CURLOPTTYPE_FUNCTIONPOINT!, 312),

    # Data passed to the PREREQFUNCTION callback
    CURLOPT!(PREREQDATA, CURLOPTTYPE_CBPOINT!, 313),

    # maximum age (since creation) of a connection to consider it for reuse* (in seconds)
    CURLOPT!(MAXLIFETIME_CONN, CURLOPTTYPE_LONG!, 314),

    # Set MIME option flags.
    CURLOPT!(MIME_OPTIONS, CURLOPTTYPE_LONG!, 315),

    LASTENTRY = 316
};

const CURL_HTTP_VERSION_NONE: i32 = 0;
const CURL_HTTP_VERSION_1_0: i32 = 1;
const CURL_HTTP_VERSION_1_1: i32 = 2;
const CURL_HTTP_VERSION_2_0: i32 = 3;
const CURL_HTTP_VERSION_2: i32 = 3;
const CURL_HTTP_VERSION_2TLS: i32 = 4;
const CURL_HTTP_VERSION_2_PRIOR_KNOWLEDGE: i32 = 5;
const CURL_HTTP_VERSION_3: i32 = 30;
const CURL_HTTP_VERSION_LAST: i32 = 31; # never use

const CURL_RTSPREQ_NONE: i32 = 0;
const CURL_RTSPREQ_OPTIONS: i32 = 1;
const CURL_RTSPREQ_DESCRIBE: i32 = 2;
const CURL_RTSPREQ_ANNOUNCE: i32 = 3;
const CURL_RTSPREQ_SETUP: i32 = 4;
const CURL_RTSPREQ_PLAY: i32 = 5;
const CURL_RTSPREQ_PAUSE: i32 = 6;
const CURL_RTSPREQ_TEARDOWN: i32 = 7;
const CURL_RTSPREQ_GET_PARAMETER: i32 = 8;
const CURL_RTSPREQ_SET_PARAMETER: i32 = 9;
const CURL_RTSPREQ_RECORD: i32 = 10;
const CURL_RTSPREQ_RECEIVE: i32 = 11;
const CURL_RTSPREQ_LAST: i32 = 12; # never use

type CURL_NETRC_OPTION: CURL_NETRC;
type CURL_NETRC: enum {
    IGNORED,
    OPTIONAL,
    REQUIRED,
    LAST # never use
};

const CURL_SSLVERSION_DEFAULT: i32 = 0;
const CURL_SSLVERSION_TLSv1: i32 = 1;
const CURL_SSLVERSION_SSLv2: i32 = 2;
const CURL_SSLVERSION_SSLv3: i32 = 3;
const CURL_SSLVERSION_TLSv1_0: i32 = 4;
const CURL_SSLVERSION_TLSv1_1: i32 = 5;
const CURL_SSLVERSION_TLSv1_2: i32 = 6;
const CURL_SSLVERSION_TLSv1_3: i32 = 7;
const CURL_SSLVERSION_LAST: i32 = 8; # never use

const CURL_SSLVERSION_MAX_NONE: i32 = 0;
const CURL_SSLVERSION_MAX_DEFAULT: i32 = 65536;
const CURL_SSLVERSION_MAX_TLSv1_0: i32 = 262144;
const CURL_SSLVERSION_MAX_TLSv1_1: i32 = 327680;
const CURL_SSLVERSION_MAX_TLSv1_2: i32 = 393216;
const CURL_SSLVERSION_MAX_TLSv1_3: i32 = 458752;
const CURL_SSLVERSION_MAX_LAST: i32 = 524288; # never use

type CURL_TLSAUTH: enum {
    NONE,
    SRP,
    LAST # never use
};

macro CURL_REDIR_GET_ALL { 0 }
macro CURL_REDIR_POST_301 { 1 }
macro CURL_REDIR_POST_302 { 2 }
macro CURL_REDIR_POST_303 { 3 }
macro CURL_REDIR_POST_ALL {
    (CURL_REDIR_POST_301! | CURL_REDIR_POST_302! | CURL_REDIR_POST_303!)
}

type curl_TimeCond: enum {
    NONE,
    IFMODSINCE,
    IFUNMODSINCE,
    LASTMOD,
    LAST
};

macro CURL_ZERO_TERMINATED { (-1: u64) }

extern {
    fn curl_strequal(s1: const &char, s2: const &char): i32;
    fn curl_strnequal(s1: const &char, s2: const &char, n: u64): i32;
}

type curl_mime: void;
type curl_mimepart: void;

macro CURLMIMEOPT_FORMESCAPE { (1 << 0) }

extern {
    fn curl_mime_init(easy: &CURL): &curl_mime;
    fn curl_mime_free(mime: &curl_mime);
    fn curl_mime_addpart(mime: &curl_mime): &curl_mimepart;
    fn curl_mime_name(part: &curl_mimepart, name: const &char): CURLcode;
    fn curl_mime_filename(part: &curl_mimepart, filename: const &char): CURLcode;
    fn curl_mime_type(part: &curl_mimepart, mimetype: const &char): CURLcode;
    fn curl_mime_encoder(part: &curl_mimepart, encoding: const &char): CURLcode;
    fn curl_mime_data(part: &curl_mimepart, data: const &char, datasize: u64): CURLcode;
    fn curl_mime_filedata(part: &curl_mimepart, filename: const &char): CURLcode;
    fn curl_mime_data_cb(part: &curl_mimepart, datasize: curl_off_t, readfunc: curl_read_callback, seekfunk: curl_seek_callback, freefunc: curl_free_callback, arg: &void): CURLcode;
    fn curl_mime_subparts(part: &curl_mimepart, subparts: &curl_mimepart): CURLcode;
    fn curl_mime_headers(part: &curl_mimepart, headers: &curl_slist, take_ownership: i32): CURLcode;
}

type CURLformoption: enum {
    NOTHING,        #******** the first one is unused ***********
    COPYNAME,
    PTRNAME,
    NAMELENGTH,
    COPYCONTENTS,
    PTRCONTENTS,
    CONTENTSLENGTH,
    FILECONTENT,
    ARRAY,
    OBSOLETE,
    FILE,

    BUFFER,
    BUFFERPTR,
    BUFFERLENGTH,

    CONTENTTYPE,
    CONTENTHEADER,
    FILENAME,
    END,
    OBSOLETE2,

    STREAM,
    CONTENTLEN, # added in 7.46.0, provide a curl_off_t length

    LASTENTRY #the last unused
};

type curl_forms: struct {
    option: CURLformoption,
    value: const &char
};

type CURLFORMcode: enum {
    OK,
    MEMORY,
    OPTION_TWICE,
    NULL,
    UNKNOWN_OPTION,
    INCOMPLETE,
    ILLEGAL_ARRAY,
    DISABLED,
    LAST # never use
};

extern fn curl_formadd(httppost: &&curl_httppost, last_post: &&curl_httppost, args: ...): CURLFORMcode;

type curl_formget_callback: fn<u64>(&void, const &char, u64);

extern {
    fn curl_formget(form: &curl_httppost, arg: &void, append: curl_formget_callback): i32;
    fn curl_formfree(form: &curl_httppost);

    fn curl_getenv(variable: const &char): &char;
    fn curl_version(): &char;

    fn curl_easy_escape(handle: &CURL, string: const &char, length: i32): &char;
    fn curl_escape(string: const &char, length: i32): &char;
    fn curl_easy_unescape(hanle: &CURL, string: const &char, length: i32, outlength: &i32): &char;
    fn curl_unescape(string: const &char, length: i32): &char;

    fn curl_global_init(flags: i64): CURLcode;
    fn curl_global_init_mem(flags: i64, m: curl_malloc_callback, f: curl_free_callback, r: curl_realloc_callback, s: curl_strdup_callback, c: curl_calloc_callback);
    fn curl_global_cleanup();
}

type curl_slist: struct {
    data: &char,
    next: &curl_slist
};

#[
 * NAME curl_global_sslset()
 *
 * DESCRIPTION
 *
 * When built with multiple SSL backends, curl_global_sslset() allows to
 * choose one. This function can only be called once, and it must be called
 * *before* curl_global_init().
 *
 * The backend can be identified by the id (e.g. CURLSSLBACKEND_OPENSSL). The
 * backend can also be specified via the name parameter (passing -1 as id).
 * If both id and name are specified, the name will be ignored. If neither id
 * nor name are specified, the function will fail with
 * CURLSSLSET_UNKNOWN_BACKEND and set the "avail" pointer to the
 * NULL-terminated list of available backends.
 *
 * Upon success, the function returns CURLSSLSET_OK.
 *
 * If the specified SSL backend is not available, the function returns
 * CURLSSLSET_UNKNOWN_BACKEND and sets the "avail" pointer to a NULL-terminated
 * list of available SSL backends.
 *
 * The SSL backend can be set only once. If it has already been set, a
 * subsequent attempt to change it will result in a CURLSSLSET_TOO_LATE.
 ]#

type curl_ssl_backend: struct {
    id: curl_sslbackend,
    name: const &char
};

type CURLsslset: enum {
    OK,
    UNKNOWN_BACKEND,
    TOO_LATE,
    NO_BACKENDS
};

extern {
    fn curl_global_sslset(id: curl_sslbackend, name: const &char, avail: const &&&curl_ssl_backend): CURLsslset;

    fn curl_slist_append(list: &curl_slist, new: const &char): &curl_slist;
    fn curl_slist_free_all(list: &curl_slist);

    fn curl_getdate(p: const &char, unused: const &std::time_t): std::time_t;
}

type curl_certinfo: struct {
    num_of_certs: i32,
    certinfo: &&curl_slist
};

type curl_tlssessioninfo: struct {
    backend: curl_sslbackend,
    internals: &void
};

macro CURLINFO_STRING   { 0x100000 }
macro CURLINFO_LONG     { 0x200000 }
macro CURLINFO_DOUBLE   { 0x300000 }
macro CURLINFO_SLIST    { 0x400000 }
macro CURLINFO_PTR      { 0x400000 } # same as SLIST
macro CURLINFO_SOCKET   { 0x500000 }
macro CURLINFO_OFF_T    { 0x600000 }
macro CURLINFO_MASK     { 0x0fffff }
macro CURLINFO_TYPEMASK { 0xf00000 }

type CURLINFO: enum {
    NONE, # first, never use this
    EFFECTIVE_URL    = 1048577,
    RESPONSE_CODE    = 2097154,
    TOTAL_TIME       = 3145731,
    NAMELOOKUP_TIME  = CURLINFO_DOUBLE! + 4,
    CONNECT_TIME     = CURLINFO_DOUBLE! + 5,
    PRETRANSFER_TIME = CURLINFO_DOUBLE! + 6,
    SIZE_UPLOAD      = CURLINFO_DOUBLE! + 7,
    SIZE_UPLOAD_T    = CURLINFO_OFF_T!  + 7,
    SIZE_DOWNLOAD    = CURLINFO_DOUBLE! + 8,
    SIZE_DOWNLOAD_T  = CURLINFO_OFF_T!  + 8,
    SPEED_DOWNLOAD   = CURLINFO_DOUBLE! + 9,
    SPEED_DOWNLOAD_T = CURLINFO_OFF_T!  + 9,
    SPEED_UPLOAD     = CURLINFO_DOUBLE! + 10,
    SPEED_UPLOAD_T   = CURLINFO_OFF_T!  + 10,
    HEADER_SIZE      = CURLINFO_LONG!   + 11,
    REQUEST_SIZE     = CURLINFO_LONG!   + 12,
    SSL_VERIFYRESULT = CURLINFO_LONG!   + 13,
    FILETIME         = CURLINFO_LONG!   + 14,
    FILETIME_T       = CURLINFO_OFF_T!  + 14,
    CONTENT_LENGTH_DOWNLOAD   = CURLINFO_DOUBLE! + 15,
    CONTENT_LENGTH_DOWNLOAD_T = CURLINFO_OFF_T!  + 15,
    CONTENT_LENGTH_UPLOAD     = CURLINFO_DOUBLE! + 16,
    CONTENT_LENGTH_UPLOAD_T   = CURLINFO_OFF_T!  + 16,
    STARTTRANSFER_TIME = CURLINFO_DOUBLE! + 17,
    CONTENT_TYPE     = CURLINFO_STRING!   + 18,
    REDIRECT_TIME    = CURLINFO_DOUBLE!   + 19,
    REDIRECT_COUNT   = CURLINFO_LONG!     + 20,
    PRIVATE          = CURLINFO_STRING!   + 21,
    HTTP_CONNECTCODE = CURLINFO_LONG!     + 22,
    HTTPAUTH_AVAIL   = CURLINFO_LONG!     + 23,
    PROXYAUTH_AVAIL  = CURLINFO_LONG!     + 24,
    OS_ERRNO         = CURLINFO_LONG!     + 25,
    NUM_CONNECTS     = CURLINFO_LONG!     + 26,
    SSL_ENGINES      = CURLINFO_SLIST!    + 27,
    COOKIELIST       = CURLINFO_SLIST!    + 28,
    LASTSOCKET       = CURLINFO_LONG!     + 29,
    FTP_ENTRY_PATH   = CURLINFO_STRING!   + 30,
    REDIRECT_URL     = CURLINFO_STRING!   + 31,
    PRIMARY_IP       = CURLINFO_STRING!   + 32,
    APPCONNECT_TIME  = CURLINFO_DOUBLE!   + 33,
    CERTINFO         = CURLINFO_PTR!      + 34,
    CONDITION_UNMET  = CURLINFO_LONG!     + 35,
    RTSP_SESSION_ID  = CURLINFO_STRING!   + 36,
    RTSP_CLIENT_CSEQ = CURLINFO_LONG!     + 37,
    RTSP_SERVER_CSEQ = CURLINFO_LONG!     + 38,
    RTSP_CSEQ_RECV   = CURLINFO_LONG!     + 39,
    PRIMARY_PORT     = CURLINFO_LONG!     + 40,
    LOCAL_IP         = CURLINFO_STRING!   + 41,
    LOCAL_PORT       = CURLINFO_LONG!     + 42,
    TLS_SESSION      = CURLINFO_PTR!      + 43,
    ACTIVESOCKET     = CURLINFO_SOCKET!   + 44,
    TLS_SSL_PTR      = CURLINFO_PTR!      + 45,
    HTTP_VERSION     = CURLINFO_LONG!     + 46,
    PROXY_SSL_VERIFYRESULT = CURLINFO_LONG! + 47,
    PROTOCOL         = CURLINFO_LONG!      + 48,
    SCHEME           = CURLINFO_STRING!    + 49,
    TOTAL_TIME_T     = CURLINFO_OFF_T!     + 50,
    NAMELOOKUP_TIME_T = CURLINFO_OFF_T!    + 51,
    CONNECT_TIME_T   = CURLINFO_OFF_T!     + 52,
    PRETRANSFER_TIME_T = CURLINFO_OFF_T!   + 53,
    STARTTRANSFER_TIME_T = CURLINFO_OFF_T! + 54,
    REDIRECT_TIME_T  = CURLINFO_OFF_T!  + 55,
    APPCONNECT_TIME_T = CURLINFO_OFF_T! + 56,
    RETRY_AFTER      = CURLINFO_OFF_T!  + 57,
    EFFECTIVE_METHOD = CURLINFO_STRING! + 58,
    PROXY_ERROR      = CURLINFO_LONG!   + 59,
    REFERER          = CURLINFO_STRING! + 60,

    LASTONE          = 60
};

macro CURLINFO_HTTP_CODE { CURLINFO::RESPONSE_CODE }

type curl_closepolicy: enum {
    NONE,
    OLDEST,
    LEAST_RECENTLY_USED,
    LEAST_TRAFFIC,
    SLOWEST,
    CALLBACK,

    LAST # never use
};

macro CURL_GLOBAL_SSL { (1 << 0) }
macro CURL_GLOBAL_WIN32 { (1 << 1) }
macro CURL_GLOBAL_ALL { (CURL_GLOBAL_SSL! | CURL_GLOBAL_WIN32!) }
macro CURL_GLOBAL_NOTHING { 0 }
macro CURL_GLOBAL_DEFAULT { CURL_GLOBAL_ALL! }
macro CURL_GLOBAL_ACK_EINTR { (1 << 2) }

#[****************************************************************************
 * Setup defines, protos etc for the sharing stuff.
 ]#

type curl_lock_data: enum {
    NONE,
    SHARE,
    COOKIE,
    DNS,
    SSL_SESSION,
    CONNECT,
    PSL,
    LAST # never use
};

type curl_lock_access: enum {
    NONE,
    SHARED,
    SINGLE,
    LAST # never use
};

type curl_lock_function: fn(&CURL, curl_lock_data, curl_lock_access, &void);
type curl_unlock_function: fn(&CURL, curl_lock_data, &void);

type CURLSHcode: enum {
    OK,
    BAD_OPTION,
    IN_USE,
    INVALID,
    NOMEM,
    NOT_BUILT_IN,
    LAST # never use
};

type CURLSHoption: enum {
    NONE,
    SHARE,
    UNSHARE,
    LOCKFUNC,
    UNLOCKFUNC,
    USERDATA,
    LAST # never use
};

extern {
    fn curl_share_init(): &CURLSH;
    fn curl_share_setopt(c: &CURLSH, option: CURLSHoption, args: ...): CURLSHcode;
    fn curl_share_cleanup(c: &CURLSH): &CURLSHcode;
}

type CURLversion: enum {
    FIRST,
    SECOND,
    THIRD,
    FOURTH,
    FIFTH,
    SIXTH,
    SEVENTH,
    EIGHTH,
    NINTH,
    TENTH,
    LAST # never use
};

macro CURLVERSION_NOW { ::CURLversion::TENTH }

type curl_version_info_data: struct {
    age: CURLversion,
    version: const &char,
    version_num: u32,
    host: const &char,
    features: i32,
    ssl_version: const &char,
    ssl_version_num: i64,
    libz_version: const &char,
    protocols: const &const &char,

    ares: const &char,
    ares_num: i32,

    libidn: const &char,

    iconv_ver_num: i32,

    libssh_version: const &char,

    brotli_ver_num: u32,
    brotli_version: const &char,

    nghttp2_ver_num: u32,
    nghttp2_version: const &char,
    quic_versoin: const &char,

    cainfo: const &char,
    capath: const &char,

    zstd_ver_num: u32,
    zstd_version: const &char,

    hyper_version: const &char,

    gsasl_version: const &char
};

macro CURL_VERSION_IPV6         { (1<<0)  } # IPv6-enabled
macro CURL_VERSION_KERBEROS4    { (1<<1)  } # Kerberos V4 auth is supported (deprecated)
macro CURL_VERSION_SSL          { (1<<2)  } # SSL options are present
macro CURL_VERSION_LIBZ         { (1<<3)  } # libz features are present
macro CURL_VERSION_NTLM         { (1<<4)  } # NTLM auth is supported
macro CURL_VERSION_GSSNEGOTIATE { (1<<5)  } # Negotiate auth is supported (deprecated)
macro CURL_VERSION_DEBUG        { (1<<6)  } # Built with debug capabilities
macro CURL_VERSION_ASYNCHDNS    { (1<<7)  } # Asynchronous DNS resolves
macro CURL_VERSION_SPNEGO       { (1<<8)  } # SPNEGO auth is supported
macro CURL_VERSION_LARGEFILE    { (1<<9)  } # Supports files larger than 2GB
macro CURL_VERSION_IDN          { (1<<10) } # Internationized Domain Names are supported
macro CURL_VERSION_SSPI         { (1<<11) } # Built against Windows SSPI
macro CURL_VERSION_CONV         { (1<<12) } # Character conversions supported
macro CURL_VERSION_CURLDEBUG    { (1<<13) } # Debug memory tracking supported
macro CURL_VERSION_TLSAUTH_SRP  { (1<<14) } # TLS-SRP auth is supported
macro CURL_VERSION_NTLM_WB      { (1<<15) } # NTLM delegation to winbind helper is supported
macro CURL_VERSION_HTTP2        { (1<<16) } # HTTP2 support built-in
macro CURL_VERSION_GSSAPI       { (1<<17) } # Built against a GSS-API library
macro CURL_VERSION_KERBEROS5    { (1<<18) } # Kerberos V5 auth is supported
macro CURL_VERSION_UNIX_SOCKETS { (1<<19) } # Unix domain sockets support
macro CURL_VERSION_PSL          { (1<<20) } # Mozilla's Public Suffix List, used for cookie domain verification
macro CURL_VERSION_HTTPS_PROXY  { (1<<21) } # HTTPS-proxy support built-in
macro CURL_VERSION_MULTI_SSL    { (1<<22) } # Multiple SSL backends available
macro CURL_VERSION_BROTLI       { (1<<23) } # Brotli features are present.
macro CURL_VERSION_ALTSVC       { (1<<24) } # Alt-Svc handling built-in
macro CURL_VERSION_HTTP3        { (1<<25) } # HTTP3 support built-in
macro CURL_VERSION_ZSTD         { (1<<26) } # zstd features are present
macro CURL_VERSION_UNICODE      { (1<<27) } # Unicode support on Windows
macro CURL_VERSION_HSTS         { (1<<28) } # HSTS is supported
macro CURL_VERSION_GSASL        { (1<<29) } # libgsasl is supported

extern {
    fn curl_version_info(version: CURLversion): &curl_version_info_data;
    fn curl_easy_stderr(code: CURLcode): const &char;
    fn curl_share_strerror(code: CURLSHcode): const &char;
    fn curl_easy_pause(handle: &CURL, bitmask: i32): CURLcode;
}

macro CURLPAUSE_RECV      { (1<<0) }
macro CURLPAUSE_RECV_CONT { (0) }
macro CURLPAUSE_SEND      { (1<<2) }
macro CURLPAUSE_SEND_CONT { (0) }
macro CURLPAUSE_ALL       { (CURLPAUSE_RECV|CURLPAUSE_SEND) }
macro CURLPAUSE_CONT      { (CURLPAUSE_RECV_CONT|CURLPAUSE_SEND_CONT) }