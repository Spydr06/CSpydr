#[**************************************************************************
 *                                  _   _ ____  _
 *  Project                     ___| | | |  _ \| |
 *                             / __| | | | |_) | |
 *                            | (__| |_| |  _ <| |___
 *                             \___|\___/|_| \_\_____|
 *
 * Copyright (C) 1998 - 2022, Daniel Stenberg, <daniel@haxx.se>, et al.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution. The terms
 * are also available at https://curl.se/docs/copyright.html.
 *
 * You may opt to use, copy, modify, merge, publish, distribute and/or sell
 * copies of the Software, and permit persons to whom the Software is
 * furnished to do so, under the terms of the COPYING file.
 *
 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
 * KIND, either express or implied.
 *
 **************************************************************************]#

[link("curl")]

import "curl_system.csp";
import "curlver.csp";
import "types.csp";
import "system.csp";
import "multi.csp";
import "easy.csp";
import "urlapi.csp";
import "options.csp";

type CURL: void;
type CURLSH: void;

type curl_socket_t: i32;

macro CURL_SOCKET_BAD { (-1) }

type curl_sslbackend: enum {
    NONE = 0,
    OPENSSL = 1,
    GNUTLS = 2,
    NSS = 3,
    OBSOLETE4 = 4,  # Was QSOSSL.
    GSKIT = 5,
    POLARSSL = 6,
    WOLFSSL = 7,
    SCHANNEL = 8,
    SECURETRANSPORT = 9,
    AXTLS = 10, # never used since 7.63.0
    MBEDTLS = 11,
    MESALINK = 12,
    BEARSSL = 13,
    RUSTLS = 14
};

macro CURLSSLBACKEND_LIBRESSL { ::curl_sslbackend::OPENSSL }
macro CURLSSLBACKEND_BORINGSSL { ::curl_sslbackend::OPENSSL }
macro CURLSSLBACKEND_CYASSL { ::curl_sslbackend::WOLFSSL }
macro CURLSSLBACKEND_DARWINSSL { ::curl_sslbackend::SECURETRANSPORT }

type curl_httppost: struct {
    next: &curl_httppost,
    name: &char,
    namelength: i64,
    contents: &char,
    contentslength: i64,
    buffer: &char,
    bufferlength: i64,
    contenttype: &char,
    contentheader: &curl_slist,
    more: &curl_httppost,
    flags: i64,

macro CURL_HTTPPOST_FILENAME { (1 << 0) }
macro CURL_HTTPPOST_READFILE { (1 << 1) }
macro CURL_HTTPPOST_PTRNAME { (1 << 2) }
macro CURL_HTTPPOST_PTRCONTENTS { (1 << 3) }
macro CURL_HTTPPOST_BUFFER { (1 << 4) }
macro CURL_HTTPPOST_PTRBUFFER { (1 << 5) }
macro CURL_HTTPPOST_CALLBACK { (1 << 6) }
macro CURL_HTTPPOST_LARGE { (1 << 7) }

    showfilename: &char,
    userp: &void,
    contentlen: curl_off_t
};

macro CURL_PROGRESSFUNC_CONTINUE { 0x10000001 }

type curl_progress_callback: fn<i32>(&void, f64, f64, f64, f64);
type curl_xferinfo_callback: fn<i32>(&void, curl_off_t, curl_off_t, curl_off_t, curl_off_t);

macro CURL_MAX_READ_SIZE { 524288 }
macro CURL_MAX_WRITE_SIZE { 16384 }
macro CURL_MAX_HTTP_HEADER { (100*1024) }
macro CURL_WRITEFUNC_PAUSE { 0x10000001 }

type curl_write_callback: fn<u64>(&char, u64, u64, &void);
type curl_resolver_start_callback: fn<i32>(&void, &void, &void);

type curlfiletype: enum {
    FILE = 0,
    DIRECTORY,
    SYMLINK,
    DEVICE_BLOCK,
    DEVICE_CHAR,
    NAMEDPIPE,
    SOCKET,
    DOOR, # is possible only on Sun Solaris now

    UNKNOWN # should never occur
};

macro CURLFINFOFLAG_KNOWN_FILENAME   { (1<<0) }
macro CURLFINFOFLAG_KNOWN_FILETYPE   { (1<<1) }
macro CURLFINFOFLAG_KNOWN_TIME       { (1<<2) }
macro CURLFINFOFLAG_KNOWN_PERM       { (1<<3) }
macro CURLFINFOFLAG_KNOWN_UID        { (1<<4) }
macro CURLFINFOFLAG_KNOWN_GID        { (1<<5) }
macro CURLFINFOFLAG_KNOWN_SIZE       { (1<<6) }
macro CURLFINFOFLAG_KNOWN_HLINKCOUNT { (1<<7) }

type curl_fileinfo: struct {
    filename: &char,
    filetype: curlfiletype,
    time: std::time_t,
    perm: u32,
    uid: i32,
    gid: i32,
    size: curl_off_t,
    hardlinks: i64,

    strings: struct {
        time: &char,
        perm: &char,
        user: &char,
        group: &char,
        target: &char
    },

    flags: u32,
    b_data: &char,
    b_size: u64,
    b_used: u64
};

# return codes for CURLOPT_CHUNK_BGN_FUNCTION
macro CURL_CHUNK_BGN_FUNC_OK     { 0 }
macro CURL_CHUNK_BGN_FUNC_FAIL   { 1 } # tell the lib to end the task
macro CURL_CHUNK_BGN_FUNC_SKIP   { 2 } # skip this chunk over

type curl_chunk_bgn_callback: fn<i64>(const &void, &void, i32);

# return codes for CURLOPT_CHUNK_END_FUNCTION
macro CURL_CHUNK_END_FUNC_OK     { 0 }
macro CURL_CHUNK_END_FUNC_FAIL   { 1 } # tell the lib to end the task

type curl_chunk_end_callback: fn<i64>(&void);

# return codes for FNMATCHFUNCTION
macro CURL_FNMATCHFUNC_MATCH   { 0 } # string corresponds to the pattern
macro CURL_FNMATCHFUNC_NOMATCH { 1 } # pattern doesn't match the string
macro CURL_FNMATCHFUNC_FAIL    { 2 } # an error occurred

type curl_fnmatch_callback: fn<i32>(&void, const &char, const &char);

# These are the return codes for the seek callbacks
macro CURL_SEEKFUNC_OK       { 0 }
macro CURL_SEEKFUNC_FAIL     { 1 } # fail the entire transfer
macro CURL_SEEKFUNC_CANTSEEK { 2 } # tell libcurl seeking can't be done, so libcurl might try other means instead

type curl_seek_callback: fn<i32>(&void, curl_off_t, i32);

#[ This is a return code for the read callback that, when returned, will
   signal libcurl to immediately abort the current transfer. ]#
macro CURL_READFUNC_ABORT { 0x10000000 }
#[ This is a return code for the read callback that, when returned, will
   signal libcurl to pause sending data on the current transfer. ]#
macro CURL_READFUNC_PAUSE { 0x10000001 }

#[ Return code for when the trailing headers' callback has terminated
   without any errors]#
macro CURL_TRAILERFUNC_OK { 0 }
#[ Return code for when was an error in the trailing header's list and we
  want to abort the request ]#
macro CURL_TRAILERFUNC_ABORT { 1 }

type curl_read_callback: fn<u64>(&char, u64, u64, &void);
type curl_trailer_callback: fn<i32>(&&curl_slist, &void);

type curlsocktype: enum {
    IPCXN,  # socket created for a specific IP connection
    ACCEPT, # socket created by accept() call
    LAST    # never use
};

macro CURL_SOCKOPT_OK { 0 }
macro CURL_SOCKOPT_ERROR { 1 }
macro CURL_SOCKOPT_ALREADY_CONNECTED { 2 }

type curl_sockopt_callback: fn<i32>(&void, curl_socket_t, curlsocktype);

type curl_sockaddr: struct {
    family: i32,
    socktype: i32,
    protocol: i32,
    addrlen: u32,
    addr: std::SockAddr
};

type curl_opensocket_callback: fn<curl_socket_t>(&void, curlsocktype, &curl_sockaddr);
type curl_closesocket_callback: fn<i32>(&void, curl_socket_t);

type curlioerr: enum {
    OK,          # I/O operation successful
    UNKNOWNCMD,  # command was unknown to callback
    FAILRESTART, # failed to restart the read
    LAST         # never use
};

type curliocmd: enum {
    NOP,         # no operation
    RESTARTREAD, # restart the read stream from start
    LAST         # never use
};

type curl_ioctl_callback: fn<curlioerr>(&CURL, i32, &void);
type curl_malloc_callback: fn<&void>(u64);
type curl_free_callback: fn(&void);
type curl_realloc_callback: fn<&void>(&void, u64);
type curl_strdup_callback: fn<&char>(const &char);
type curl_calloc_callback: fn<&void>(u64, u64);

macro CURL_DID_MEMORY_FUNC_TYPEDEFS {}

type curl_infotype: enum {
    TEXT = 0,
    HEADER_IN,    # 1
    HEADER_OUT,   # 2
    DATA_IN,      # 3
    DATA_OUT,     # 4
    SSL_DATA_IN,  # 5
    SSL_DATA_OUT, # 6
    END
};

type curl_debug_callback: fn<i32>(&CURL, curl_infotype, &char, u64, &void);
type curl_prereq_callback: fn<i32>(&void, &char, &char, i32, i32);

macro CURL_PREREQFUNC_OK { 0 }
macro CURL_PREREQFUNC_ABORT { 1 }

type CURLcode: enum {
    OK = 0,
    UNSUPPORTED_PROTOCOL,    # 1
    FAILED_INIT,             # 2
    URL_MALFORMAT,           # 3
    NOT_BUILT_IN,            # 4 - [was obsoleted in August 2007 for 7.17.0, reused in April 2011 for 7.21.5]
    COULDNT_RESOLVE_PROXY,   # 5
    COULDNT_RESOLVE_HOST,    # 6
    COULDNT_CONNECT,         # 7
    WEIRD_SERVER_REPLY,      # 8
    REMOTE_ACCESS_DENIED,    # 9 a service was denied by the server due to lack of access - when login fails this is not returned.
    FTP_ACCEPT_FAILED,       # 10 - [was obsoleted in April 2006 for 7.15.4, reused in Dec 2011 for 7.24.0]
    FTP_WEIRD_PASS_REPLY,    # 11
    FTP_ACCEPT_TIMEOUT,      # 12 - timeout occurred accepting server [was obsoleted in August 2007 for 7.17.0, reused in Dec 2011 for 7.24.0]
    FTP_WEIRD_PASV_REPLY,    # 13
    FTP_WEIRD_227_FORMAT,    # 14
    FTP_CANT_GET_HOST,       # 15
    HTTP2,                   # 16 - A problem in the http2 framing layer. [was obsoleted in August 2007 for 7.17.0, reused in July 2014 for 7.38.0]
    FTP_COULDNT_SET_TYPE,    # 17
    PARTIAL_FILE,            # 18
    FTP_COULDNT_RETR_FILE,   # 19
    OBSOLETE20,              # 20 - NOT USED
    QUOTE_ERROR,             # 21 - quote command failure
    HTTP_RETURNED_ERROR,     # 22
    WRITE_ERROR,             # 23
    OBSOLETE24,              # 24 - NOT USED
    UPLOAD_FAILED,           # 25 - failed upload "command"
    READ_ERROR,              # 26 - couldn't open/read from file
    OUT_OF_MEMORY,           # 27
    OPERATION_TIMEDOUT,      # 28 - the timeout time was reached
    OBSOLETE29,              # 29 - NOT USED
    FTP_PORT_FAILED,         # 30 - FTP PORT operation failed
    FTP_COULDNT_USE_REST,    # 31 - the REST command failed
    OBSOLETE32,              # 32 - NOT USED
    RANGE_ERROR,             # 33 - RANGE "command" didn't work
    HTTP_POST_ERROR,         # 34
    SSL_CONNECT_ERROR,       # 35 - wrong when connecting with SSL
    BAD_DOWNLOAD_RESUME,     # 36 - couldn't resume download
    FILE_COULDNT_READ_FILE,  # 37
    LDAP_CANNOT_BIND,        # 38
    LDAP_SEARCH_FAILED,      # 39
    OBSOLETE40,              # 40 - NOT USED
    FUNCTION_NOT_FOUND,      # 41 - NOT USED starting with 7.53.0
    ABORTED_BY_CALLBACK,     # 42
    BAD_FUNCTION_ARGUMENT,   # 43
    OBSOLETE44,              # 44 - NOT USED
    INTERFACE_FAILED,        # 45 - CURLOPT_INTERFACE failed
    OBSOLETE46,              # 46 - NOT USED
    TOO_MANY_REDIRECTS,      # 47 - catch endless re-direct loops
    UNKNOWN_OPTION,          # 48 - User specified an unknown option
    SETOPT_OPTION_SYNTAX,    # 49 - Malformed setopt option
    OBSOLETE50,              # 50 - NOT USED
    OBSOLETE51,              # 51 - NOT USED
    GOT_NOTHING,             # 52 - when this is a specific error
    SSL_ENGINE_NOTFOUND,     # 53 - SSL crypto engine not found
    SSL_ENGINE_SETFAILED,    # 54 - can not set SSL crypto engine as default
    SEND_ERROR,              # 55 - failed sending network data
    RECV_ERROR,              # 56 - failure in receiving network data
    OBSOLETE57,              # 57 - NOT IN USE
    SSL_CERTPROBLEM,         # 58 - problem with the local certificate
    SSL_CIPHER,              # 59 - couldn't use specified cipher
    PEER_FAILED_VERIFICATION, # 60 - peer's certificate or fingerprint wasn't verified fine
    BAD_CONTENT_ENCODING,    # 61 - Unrecognized/bad encoding
    OBSOLETE62,              # 62 - NOT IN USE since 7.82.0
    FILESIZE_EXCEEDED,       # 63 - Maximum file size exceeded
    USE_SSL_FAILED,          # 64 - Requested FTP SSL level failed
    SEND_FAIL_REWIND,        # 65 - Sending the data requires a rewind that failed
    SSL_ENGINE_INITFAILED,   # 66 - failed to initialise ENGINE
    LOGIN_DENIED,            # 67 - user, password or similar was not accepted and we failed to login
    TFTP_NOTFOUND,           # 68 - file not found on server
    TFTP_PERM,               # 69 - permission problem on server
    REMOTE_DISK_FULL,        # 70 - out of disk space on server
    TFTP_ILLEGAL,            # 71 - Illegal TFTP operation
    TFTP_UNKNOWNID,          # 72 - Unknown transfer ID
    REMOTE_FILE_EXISTS,      # 73 - File already exists
    TFTP_NOSUCHUSER,         # 74 - No such user
    CONV_FAILED,             # 75 - conversion failed
    OBSOLETE76,              # 76 - NOT IN USE since 7.82.0
    SSL_CACERT_BADFILE,      # 77 - could not load CACERT file, missing or wrong format
    REMOTE_FILE_NOT_FOUND,   # 78 - remote file not found
    SSH,                     # 79 - error from the SSH layer, somewhat generic so the error message will be of interest when this has happened

    SSL_SHUTDOWN_FAILED,     # 80 - Failed to shut down the SSL connection
    AGAIN,                   # 81 - socket is not ready for send/recv, wait till it's ready and try again (Added in 7.18.2)
    SSL_CRL_BADFILE,         # 82 - could not load CRL file, missing or wrong format (Added in 7.19.0)
    SSL_ISSUER_ERROR,        # 83 - Issuer check failed.  (Added in 7.19.0)
    FTP_PRET_FAILED,         # 84 - a PRET command failed
    RTSP_CSEQ_ERROR,         # 85 - mismatch of RTSP CSeq numbers
    RTSP_SESSION_ERROR,      # 86 - mismatch of RTSP Session Ids
    FTP_BAD_FILE_LIST,       # 87 - unable to parse FTP file list
    CHUNK_FAILED,            # 88 - chunk callback reported error
    NO_CONNECTION_AVAILABLE, # 89 - No connection available, the session will be queued
    SSL_PINNEDPUBKEYNOTMATCH, # 90 - specified pinned public key did not match
    SSL_INVALIDCERTSTATUS,   # 91 - invalid certificate status
    HTTP2_STREAM,            # 92 - stream error in HTTP/2 framing layer
                                     
    RECURSIVE_API_CALL,      # 93 - an api function was called from inside a callback
    AUTH_ERROR,              # 94 - an authentication function returned an error
    HTTP3,                   # 95 - An HTTP/3 layer problem
    QUIC_CONNECT_ERROR,      # 96 - QUIC connection error
    PROXY,                   # 97 - proxy handshake error
    SSL_CLIENTCERT,          # 98 - client-side certificate required
    LAST # never use!
};
#[
#ifndef CURL_NO_OLDIES # define this to test if your app builds with all the obsolete stuff removed! 

# Previously obsolete error code re-used in 7.38.0 
macro CURLE_OBSOLETE16 { CURLcode::HTTP2 }

# Previously obsolete error codes re-used in 7.24.0 
macro CURLE_OBSOLETE10 { CURLcode::FTP_ACCEPT_FAILED }
macro CURLE_OBSOLETE12 { CURLcode::FTP_ACCEPT_TIMEOUT }

#  compatibility with older names 
macro CURLOPT_ENCODING CURLOPT_ACCEPT_ENCODING
macro CURLE_FTP_WEIRD_SERVER_REPLY CURLE_WEIRD_SERVER_REPLY

# The following were added in 7.62.0 
macro CURLE_SSL_CACERT CURLE_PEER_FAILED_VERIFICATION

# The following were added in 7.21.5, April 2011 
macro CURLE_UNKNOWN_TELNET_OPTION CURLE_UNKNOWN_OPTION

# Added for 7.78.0 
macro CURLE_TELNET_OPTION_SYNTAX CURLE_SETOPT_OPTION_SYNTAX

# The following were added in 7.17.1 
# These are scheduled to disappear by 2009 
macro CURLE_SSL_PEER_CERTIFICATE CURLE_PEER_FAILED_VERIFICATION

# The following were added in 7.17.0 
# These are scheduled to disappear by 2009 
macro CURLE_OBSOLETE CURLE_OBSOLETE50 # no one should be using this! 
macro CURLE_BAD_PASSWORD_ENTERED CURLE_OBSOLETE46
macro CURLE_BAD_CALLING_ORDER CURLE_OBSOLETE44
macro CURLE_FTP_USER_PASSWORD_INCORRECT CURLE_OBSOLETE10
macro CURLE_FTP_CANT_RECONNECT CURLE_OBSOLETE16
macro CURLE_FTP_COULDNT_GET_SIZE CURLE_OBSOLETE32
macro CURLE_FTP_COULDNT_SET_ASCII CURLE_OBSOLETE29
macro CURLE_FTP_WEIRD_USER_REPLY CURLE_OBSOLETE12
macro CURLE_FTP_WRITE_ERROR CURLE_OBSOLETE20
macro CURLE_LIBRARY_NOT_FOUND CURLE_OBSOLETE40
macro CURLE_MALFORMAT_USER CURLE_OBSOLETE24
macro CURLE_SHARE_IN_USE CURLE_OBSOLETE57
macro CURLE_URL_MALFORMAT_USER CURLE_NOT_BUILT_IN

macro CURLE_FTP_ACCESS_DENIED CURLE_REMOTE_ACCESS_DENIED
macro CURLE_FTP_COULDNT_SET_BINARY CURLE_FTP_COULDNT_SET_TYPE
macro CURLE_FTP_QUOTE_ERROR CURLE_QUOTE_ERROR
macro CURLE_TFTP_DISKFULL CURLE_REMOTE_DISK_FULL
macro CURLE_TFTP_EXISTS CURLE_REMOTE_FILE_EXISTS
macro CURLE_HTTP_RANGE_ERROR CURLE_RANGE_ERROR
macro CURLE_FTP_SSL_FAILED CURLE_USE_SSL_FAILED

# The following were added earlier 

macro CURLE_OPERATION_TIMEOUTED CURLE_OPERATION_TIMEDOUT
macro CURLE_HTTP_NOT_FOUND CURLE_HTTP_RETURNED_ERROR
macro CURLE_HTTP_PORT_FAILED CURLE_INTERFACE_FAILED
macro CURLE_FTP_COULDNT_STOR_FILE CURLE_UPLOAD_FAILED
macro CURLE_FTP_PARTIAL_FILE CURLE_PARTIAL_FILE
macro CURLE_FTP_BAD_DOWNLOAD_RESUME CURLE_BAD_DOWNLOAD_RESUME
macro CURLE_LDAP_INVALID_URL CURLE_OBSOLETE62
macro CURLE_CONV_REQD CURLE_OBSOLETE76

# This was the error code 50 in 7.7.3 and a few earlier versions, this is no longer used by libcurl but is instead macrod here only to no make programs break 
macro CURLE_ALREADY_COMPLETE { 99999 }

# Provide defines for really old option names 
macro CURLOPT_FILE CURLOPT_WRITEDATA # name changed in 7.9.7 
macro CURLOPT_INFILE CURLOPT_READDATA # name changed in 7.9.7 
macro CURLOPT_WRITEHEADER CURLOPT_HEADERDATA

# Since long deprecated options with no code in the lib that does anything with them. 
macro CURLOPT_WRITEINFO CURLOPT_OBSOLETE40
macro CURLOPT_CLOSEPOLICY CURLOPT_OBSOLETE72]#

#
# TODO: this, multi.csp
#

type CURLproxycode: enum {
    CURLPX_OK,
    CURLPX_BAD_ADDRESS_TYPE,
    CURLPX_BAD_VERSION,
    CURLPX_CLOSED,
    CURLPX_GSSAPI,
    CURLPX_GSSAPI_PERMSG,
    CURLPX_GSSAPI_PROTECTION,
    CURLPX_IDENTD,
    CURLPX_IDENTD_DIFFER,
    CURLPX_LONG_HOSTNAME,
    CURLPX_LONG_PASSWD,
    CURLPX_LONG_USER,
    CURLPX_NO_AUTH,
    CURLPX_RECV_ADDRESS,
    CURLPX_RECV_AUTH,
    CURLPX_RECV_CONNECT,
    CURLPX_RECV_REQACK,
    CURLPX_REPLY_ADDRESS_TYPE_NOT_SUPPORTED,
    CURLPX_REPLY_COMMAND_NOT_SUPPORTED,
    CURLPX_REPLY_CONNECTION_REFUSED,
    CURLPX_REPLY_GENERAL_SERVER_FAILURE,
    CURLPX_REPLY_HOST_UNREACHABLE,
    CURLPX_REPLY_NETWORK_UNREACHABLE,
    CURLPX_REPLY_NOT_ALLOWED,
    CURLPX_REPLY_TTL_EXPIRED,
    CURLPX_REPLY_UNASSIGNED,
    CURLPX_REQUEST_FAILED,
    CURLPX_RESOLVE_HOST,
    CURLPX_SEND_AUTH,
    CURLPX_SEND_CONNECT,
    CURLPX_SEND_REQUEST,
    CURLPX_UNKNOWN_FAIL,
    CURLPX_UNKNOWN_MODE,
    CURLPX_USER_REJECTED,
    CURLPX_LAST # never use
};

type curl_conv_callback: fn<CURLcode>(&char, u64);
type curl_ssl_ctx_callback: fn<CURLcode>(&CURL, &void, &void);

type curl_proxytype: enum {
    CURLPROXY_HTTP = 0,   # added in 7.10, new in 7.19.4 default is to use CONNECT HTTP/1.1
    CURLPROXY_HTTP_1_0 = 1,   # added in 7.19.4, force to use CONNECT HTTP/1.0 
    CURLPROXY_HTTPS = 2, # added in 7.52.0
    CURLPROXY_SOCKS4 = 4, # support added in 7.15.2, enum existed already in 7.10
    CURLPROXY_SOCKS5 = 5, # added in 7.10
    CURLPROXY_SOCKS4A = 6, # added in 7.18.0
    CURLPROXY_SOCKS5_HOSTNAME = 7 # Use the SOCKS5 protocol but pass along the host name rather than the IP address. added in 7.18.0
}; # this enum was added in 7.10

macro CURLAUTH_NONE      { (0: u64) }
macro CURLAUTH_BASIC     { ((1: u64) << 0) }
macro CURLAUTH_DIGEST    { ((1: u64) << 1) }
macro CURLAUTH_NEGOTIATE { ((1: u64) << 2) }
# Deprecated since the advent of CURLAUTH_NEGOTIATE
macro CURLAUTH_GSSNEGOTIATE { CURLAUTH_NEGOTIATE! }
# Used for CURLOPT_SOCKS5_AUTH to stay terminologically correct
macro CURLAUTH_GSSAPI { CURLAUTH_NEGOTIATE! }
macro CURLAUTH_NTLM   { ((1: u64) << 3) }
macro CURLAUTH_DIGEST_IE { ((1: u64) << 4) }
macro CURLAUTH_NTLM_WB { ((1: u64) << 5) }
macro CURLAUTH_BEARER { ((1: u64) << 6) }
macro CURLAUTH_AWS_SIGV4 { ((1: u64) << 7) }
macro CURLAUTH_ONLY { ((1: u64) << 31) }
macro CURLAUTH_ANY { (~CURLAUTH_DIGEST_IE!) }
macro CURLAUTH_ANYSAFE { (~(CURLAUTH_BASIC! | CURLAUTH_DIGEST_IE!)) }

macro CURLSSH_AUTH_ANY { (~0) }
macro CURLSSH_AUTH_NONE { 0 }
macro CURLSSH_AUTH_PUBLICKEY { (1 << 0) }
macro CURLSSH_AUTH_PASSWORD { (1 << 1) }
macro CURLSSH_AUTH_HOST { (1 << 2) }
macro CURLSSH_AUTH_KEYBOARD { (1 << 3) }
macro CURLSSH_AUTH_AGENT { (1 << 4) }
macro CURLSSH_AUTH_GSSAPI { (1 << 5) }
macro CURLSSH_AUTH_DEFAULT { CURLSSH_AUTH_ANY! }

macro CURLGSSAPI_DELEGATION_NONE { 0 }
macro CURLGSSAPI_DELEGATION_POLICY_FLAG { (1 << 0) }
macro CURLGSSAPI_DELEGATION_FLAG { (1 << 1) }

macro CURL_ERROR_SIZE { 256 }

type curl_khtype: enum {
    UNKNOWN,
    RSA1,
    RSA,
    DSS,
    ECDSA,
    ED25519
};

type curl_khkey: struct {
    key: const &char,
    lenght: u64,
    keytype: curl_khtype
};

type curl_khstat: enum {
    FINE_ADD_TO_FILE,
    FINE,
    REJECT,
    DEFER,
    FINE_REPLACE,
    LAST # never use
};

type curl_khmatch: enum {
    OK,
    MISMATCH,
    MISSING,
    LAST
};

type curl_sshkeycallback: fn<i32>(&CURL, const &curl_khkey, const &curl_khkey, curl_khmatch, &void);

type curl_usessl: enum {
    NONE,
    TRY,
    CONTROL,
    ALL,
    LAST # never use
};

macro CURLSSLOPT_ALLOW_BEAST { (1 << 0) }
macro CURLSSLOPT_NO_REVOKE { (1 << 1) }
macro CURLSSLOPT_NO_PARTIALCHAIN { (1 << 2) }
macro CURLSSLOPT_REVOKE_BEST_EFFORT { (1 << 3) }
macro CURLSSLOPT_NATIVE_CA { (1 << 4) }
macro CURLSSLOPT_AUTO_CLIENT_CERT { (1 << 5) }

macro CURL_HET_DEFAULT { (200: i64) }
macro CURL_UPKEEP_INTERVAL_DEFAULT { (60000: i64) }

type curl_ftpccc: enum {
    NONE,
    PASSIVE,
    ACTIVE,
    LAST # never use
};

type curl_ftpauth: enum {
    DEFAULT,
    SSL,
    TLS,
    LAST # never use
};

type curl_ftpcreatedir: enum {
    CREATE_DIR_NONE,
    CREATE_DIR,
    CREATE_DIR_RETRY,
    LAST # never use
};

type curl_ftpmethod: enum {
    DEFAULT,
    MULITCWD,
    NOCWD,
    SINGLECWD,
    LAST # never use
};

macro CURLHEADER_UNIFIED { 0 }
macro CURLHEADER_SEPERATE { (1 << 0) }

macro CURALTSVC_READONLYFILE { (1 << 2) }
macro CURALTSVC_H1 { (1 << 3) }
macro CURALTSVC_H2 { (1 << 4) }
macro CURALTSVC_H3 { (1 << 5) }

type curl_hstsentry: struct {
    name: &char,
    namelen: u64,
    include_subdomains: u8, # FIXME: should be bit-fielded to :1
    expire: char[18]
};

type curl_index: struct {
    index: u64,
    total: u64
};

type CURLSTScode: enum {
    OK,
    DONE,
    FAIL
};

type curl_hstsread_callback: fn<CURLSTScode>(&CURL, &curl_hstsentry, &void);
type curl_hstswrite_callback: fn<CURLSTScode>(&CURL, &curl_hstsentry, &curl_index, &void);

macro CURLHSTS_ENABLE { ((1 << 0): i64) }
macro CURLHSTS_READONLYFILE { ((1 << 1): i64) }

# CURLPROTO_ defines are for the CURLOPT_*PROTOCOLS options
macro CURLPROTO_HTTP   { (1<<0) }
macro CURLPROTO_HTTPS  { (1<<1) }
macro CURLPROTO_FTP    { (1<<2) }
macro CURLPROTO_FTPS   { (1<<3) }
macro CURLPROTO_SCP    { (1<<4) }
macro CURLPROTO_SFTP   { (1<<5) }
macro CURLPROTO_TELNET { (1<<6) }
macro CURLPROTO_LDAP   { (1<<7) }
macro CURLPROTO_LDAPS  { (1<<8) }
macro CURLPROTO_DICT   { (1<<9) }
macro CURLPROTO_FILE   { (1<<10) }
macro CURLPROTO_TFTP   { (1<<11) }
macro CURLPROTO_IMAP   { (1<<12) }
macro CURLPROTO_IMAPS  { (1<<13) }
macro CURLPROTO_POP3   { (1<<14) }
macro CURLPROTO_POP3S  { (1<<15) }
macro CURLPROTO_SMTP   { (1<<16) }
macro CURLPROTO_SMTPS  { (1<<17) }
macro CURLPROTO_RTSP   { (1<<18) }
macro CURLPROTO_RTMP   { (1<<19) }
macro CURLPROTO_RTMPT  { (1<<20) }
macro CURLPROTO_RTMPE  { (1<<21) }
macro CURLPROTO_RTMPTE { (1<<22) }
macro CURLPROTO_RTMPS  { (1<<23) }
macro CURLPROTO_RTMPTS { (1<<24) }
macro CURLPROTO_GOPHER { (1<<25) }
macro CURLPROTO_SMB    { (1<<26) }
macro CURLPROTO_SMBS   { (1<<27) }
macro CURLPROTO_MQTT   { (1<<28) }
macro CURLPROTO_GOPHERS { (1<<29) }
macro CURLPROTO_ALL    { (~0) }# enable everything

macro CURLOPTTYPE_LONG          { 0 }
macro CURLOPTTYPE_OBJECTPOINT   { 10000 }
macro CURLOPTTYPE_FUNCTIONPOINT { 20000 }
macro CURLOPTTYPE_OFF_T         { 30000 }
macro CURLOPTTYPE_BLOB          { 40000 }

macro CURLOPT(na, t, nu) { 
    na = t + nu
}

# CURLOPT aliases that make no run-time difference

# 'char *' argument to a string with a trailing zero
macro CURLOPTTYPE_STRINGPOINT { CURLOPTTYPE_OBJECTPOINT }

# 'struct curl_slist *' argument
macro CURLOPTTYPE_SLISTPOINT  { CURLOPTTYPE_OBJECTPOINT }

# 'void *' argument passed untouched to callback
macro CURLOPTTYPE_CBPOINT     { CURLOPTTYPE_OBJECTPOINT }

# 'long' argument with a set of values/bitmask
macro CURLOPTTYPE_VALUES      { CURLOPTTYPE_LONG }

type CURLoption: enum {
    WRITEDATA = 10001,
    URL = 10002,
    # ...
    WRITEFUNCTION = 20011,
# TODO: this (315 enum values)
    LAST = 316
};

const CURL_HTTP_VERSION_NONE: i32 = 0;
const CURL_HTTP_VERSION_1_0: i32 = 1;
const CURL_HTTP_VERSION_1_1: i32 = 2;
const CURL_HTTP_VERSION_2_0: i32 = 3;
const CURL_HTTP_VERSION_2: i32 = 3;
const CURL_HTTP_VERSION_2TLS: i32 = 4;
const CURL_HTTP_VERSION_2_PRIOR_KNOWLEDGE: i32 = 5;
const CURL_HTTP_VERSION_3: i32 = 30;
const CURL_HTTP_VERSION_LAST: i32 = 31; # never use

const CURL_RTSPREQ_NONE: i32 = 0;
const CURL_RTSPREQ_OPTIONS: i32 = 1;
const CURL_RTSPREQ_DESCRIBE: i32 = 2;
const CURL_RTSPREQ_ANNOUNCE: i32 = 3;
const CURL_RTSPREQ_SETUP: i32 = 4;
const CURL_RTSPREQ_PLAY: i32 = 5;
const CURL_RTSPREQ_PAUSE: i32 = 6;
const CURL_RTSPREQ_TEARDOWN: i32 = 7;
const CURL_RTSPREQ_GET_PARAMETER: i32 = 8;
const CURL_RTSPREQ_SET_PARAMETER: i32 = 9;
const CURL_RTSPREQ_RECORD: i32 = 10;
const CURL_RTSPREQ_RECEIVE: i32 = 11;
const CURL_RTSPREQ_LAST: i32 = 12; # never use

type CURL_NETRC_OPTION: CURL_NETRC;
type CURL_NETRC: enum {
    IGNORED,
    OPTIONAL,
    REQUIRED,
    LAST # never use
};

const CURL_SSLVERSION_DEFAULT: i32 = 0;
const CURL_SSLVERSION_TLSv1: i32 = 1;
const CURL_SSLVERSION_SSLv2: i32 = 2;
const CURL_SSLVERSION_SSLv3: i32 = 3;
const CURL_SSLVERSION_TLSv1_0: i32 = 4;
const CURL_SSLVERSION_TLSv1_1: i32 = 5;
const CURL_SSLVERSION_TLSv1_2: i32 = 6;
const CURL_SSLVERSION_TLSv1_3: i32 = 7;
const CURL_SSLVERSION_LAST: i32 = 8; # never use

const CURL_SSLVERSION_MAX_NONE: i32 = 0;
const CURL_SSLVERSION_MAX_DEFAULT: i32 = 65536;
const CURL_SSLVERSION_MAX_TLSv1_0: i32 = 262144;
const CURL_SSLVERSION_MAX_TLSv1_1: i32 = 327680;
const CURL_SSLVERSION_MAX_TLSv1_2: i32 = 393216;
const CURL_SSLVERSION_MAX_TLSv1_3: i32 = 458752;
const CURL_SSLVERSION_MAX_LAST: i32 = 524288; # never use

type CURL_TLSAUTH: enum {
    NONE,
    SRP,
    LAST # never use
};

macro CURL_REDIR_GET_ALL { 0 }
macro CURL_REDIR_POST_301 { 1 }
macro CURL_REDIR_POST_302 { 2 }
macro CURL_REDIR_POST_303 { 3 }
macro CURL_REDIR_POST_ALL {
    (CURL_REDIR_POST_301! | CURL_REDIR_POST_302! | CURL_REDIR_POST_303!)
}

type curl_TimeCond: enum {
    NONE,
    IFMODSINCE,
    IFUNMODSINCE,
    LASTMOD,
    LAST
};

macro CURL_ZERO_TERMINATED { (-1: u64) }

extern {
    fn curl_strequal(s1: const &char, s2: const &char): i32;
    fn curl_strnequal(s1: const &char, s2: const &char, n: u64): i32;
}

type curl_mime: void;
type curl_mimepart: void;

macro CURLMIMEOPT_FORMESCAPE { (1 << 0) }

extern {
    fn curl_mime_init(easy: &CURL): &curl_mime;
    fn curl_mime_free(mime: &curl_mime);
    fn curl_mime_addpart(mime: &curl_mime): &curl_mimepart;
    fn curl_mime_name(part: &curl_mimepart, name: const &char): CURLcode;
    fn curl_mime_filename(part: &curl_mimepart, filename: const &char): CURLcode;
    fn curl_mime_type(part: &curl_mimepart, mimetype: const &char): CURLcode;
    fn curl_mime_encoder(part: &curl_mimepart, encoding: const &char): CURLcode;
    fn curl_mime_data(part: &curl_mimepart, data: const &char, datasize: u64): CURLcode;
    fn curl_mime_filedata(part: &curl_mimepart, filename: const &char): CURLcode;
    fn curl_mime_data_cb(part: &curl_mimepart, datasize: curl_off_t, readfunc: curl_read_callback, seekfunk: curl_seek_callback, freefunc: curl_free_callback, arg: &void): CURLcode;
    fn curl_mime_subparts(part: &curl_mimepart, subparts: &curl_mimepart): CURLcode;
    fn curl_mime_headers(part: &curl_mimepart, headers: &curl_slist, take_ownership: i32): CURLcode;
}

type CURLformoption: enum {
    NOTHING,        #******** the first one is unused ***********
    COPYNAME,
    PTRNAME,
    NAMELENGTH,
    COPYCONTENTS,
    PTRCONTENTS,
    CONTENTSLENGTH,
    FILECONTENT,
    ARRAY,
    OBSOLETE,
    FILE,

    BUFFER,
    BUFFERPTR,
    BUFFERLENGTH,

    CONTENTTYPE,
    CONTENTHEADER,
    FILENAME,
    END,
    OBSOLETE2,

    STREAM,
    CONTENTLEN, # added in 7.46.0, provide a curl_off_t length

    LASTENTRY #the last unused
};

type curl_forms: struct {
    option: CURLformoption,
    value: const &char
};

type CURLFORMcode: enum {
    OK,
    MEMORY,
    OPTION_TWICE,
    NULL,
    UNKNOWN_OPTION,
    INCOMPLETE,
    ILLEGAL_ARRAY,
    DISABLED,
    LAST # never use
};

extern fn curl_formadd(httppost: &&curl_httppost, last_post: &&curl_httppost, args: ...): CURLFORMcode;

type curl_formget_callback: fn<u64>(&void, const &char, u64);

extern {
    fn curl_formget(form: &curl_httppost, arg: &void, append: curl_formget_callback): i32;
    fn curl_formfree(form: &curl_httppost);

    fn curl_getenv(variable: const &char): &char;
    fn curl_version(): &char;

    fn curl_easy_escape(handle: &CURL, string: const &char, length: i32): &char;
    fn curl_escape(string: const &char, length: i32): &char;
    fn curl_easy_unescape(hanle: &CURL, string: const &char, length: i32, outlength: &i32): &char;
    fn curl_unescape(string: const &char, length: i32): &char;

    fn curl_global_init(flags: i64): CURLcode;
    fn curl_global_init_mem(flags: i64, m: curl_malloc_callback, f: curl_free_callback, r: curl_realloc_callback, s: curl_strdup_callback, c: curl_calloc_callback);
    fn curl_global_cleanup();
}

type curl_slist: struct {
    data: &char,
    next: &curl_slist
};

#[
 * NAME curl_global_sslset()
 *
 * DESCRIPTION
 *
 * When built with multiple SSL backends, curl_global_sslset() allows to
 * choose one. This function can only be called once, and it must be called
 * *before* curl_global_init().
 *
 * The backend can be identified by the id (e.g. CURLSSLBACKEND_OPENSSL). The
 * backend can also be specified via the name parameter (passing -1 as id).
 * If both id and name are specified, the name will be ignored. If neither id
 * nor name are specified, the function will fail with
 * CURLSSLSET_UNKNOWN_BACKEND and set the "avail" pointer to the
 * NULL-terminated list of available backends.
 *
 * Upon success, the function returns CURLSSLSET_OK.
 *
 * If the specified SSL backend is not available, the function returns
 * CURLSSLSET_UNKNOWN_BACKEND and sets the "avail" pointer to a NULL-terminated
 * list of available SSL backends.
 *
 * The SSL backend can be set only once. If it has already been set, a
 * subsequent attempt to change it will result in a CURLSSLSET_TOO_LATE.
 ]#

type curl_ssl_backend: struct {
    id: curl_sslbackend,
    name: const &char
};

type CURLsslset: enum {
    OK,
    UNKNOWN_BACKEND,
    TOO_LATE,
    NO_BACKENDS
};

extern {
    fn curl_global_sslset(id: curl_sslbackend, name: const &char, avail: const &&&curl_ssl_backend): CURLsslset;

    fn curl_slist_append(list: &curl_slist, new: const &char): &curl_slist;
    fn curl_slist_free_all(list: &curl_slist);

    fn curl_getdate(p: const &char, unused: const &std::time_t): std::time_t;
}

type curl_certinfo: struct {
    num_of_certs: i32,
    certinfo: &&curl_slist
};

type curl_tlssessioninfo: struct {
    backend: curl_sslbackend,
    internals: &void
};

macro CURLINFO_STRING   { 0x100000 }
macro CURLINFO_LONG     { 0x200000 }
macro CURLINFO_DOUBLE   { 0x300000 }
macro CURLINFO_SLIST    { 0x400000 }
macro CURLINFO_PTR      { 0x400000 } # same as SLIST
macro CURLINFO_SOCKET   { 0x500000 }
macro CURLINFO_OFF_T    { 0x600000 }
macro CURLINFO_MASK     { 0x0fffff }
macro CURLINFO_TYPEMASK { 0xf00000 }

type CURLINFO: enum {
    NONE, # first, never use this
    EFFECTIVE_URL    = 1048577,
    RESPONSE_CODE    = 2097154,
    TOTAL_TIME       = 3145731,
#[  NAMELOOKUP_TIME  = CURLINFO_DOUBLE + 4,
    CONNECT_TIME     = CURLINFO_DOUBLE + 5,
    PRETRANSFER_TIME = CURLINFO_DOUBLE + 6,
    SIZE_UPLOAD      = CURLINFO_DOUBLE + 7,
    SIZE_UPLOAD_T    = CURLINFO_OFF_T  + 7,
    SIZE_DOWNLOAD    = CURLINFO_DOUBLE + 8,
    SIZE_DOWNLOAD_T  = CURLINFO_OFF_T  + 8,
    SPEED_DOWNLOAD   = CURLINFO_DOUBLE + 9,
    SPEED_DOWNLOAD_T = CURLINFO_OFF_T  + 9,
    SPEED_UPLOAD     = CURLINFO_DOUBLE + 10,
    SPEED_UPLOAD_T   = CURLINFO_OFF_T  + 10,
    HEADER_SIZE      = CURLINFO_LONG   + 11,
    REQUEST_SIZE     = CURLINFO_LONG   + 12,
    SSL_VERIFYRESULT = CURLINFO_LONG   + 13,
    FILETIME         = CURLINFO_LONG   + 14,
    FILETIME_T       = CURLINFO_OFF_T  + 14,
    CONTENT_LENGTH_DOWNLOAD   = CURLINFO_DOUBLE + 15,
    CONTENT_LENGTH_DOWNLOAD_T = CURLINFO_OFF_T  + 15,
    CONTENT_LENGTH_UPLOAD     = CURLINFO_DOUBLE + 16,
    CONTENT_LENGTH_UPLOAD_T   = CURLINFO_OFF_T  + 16,
    STARTTRANSFER_TIME = CURLINFO_DOUBLE + 17,
    CONTENT_TYPE     = CURLINFO_STRING + 18,
    REDIRECT_TIME    = CURLINFO_DOUBLE + 19,
    REDIRECT_COUNT   = CURLINFO_LONG   + 20,
    PRIVATE          = CURLINFO_STRING + 21,
    HTTP_CONNECTCODE = CURLINFO_LONG   + 22,
    HTTPAUTH_AVAIL   = CURLINFO_LONG   + 23,
    PROXYAUTH_AVAIL  = CURLINFO_LONG   + 24,
    OS_ERRNO         = CURLINFO_LONG   + 25,
    NUM_CONNECTS     = CURLINFO_LONG   + 26,
    SSL_ENGINES      = CURLINFO_SLIST  + 27,
    COOKIELIST       = CURLINFO_SLIST  + 28,
    LASTSOCKET       = CURLINFO_LONG   + 29,
    FTP_ENTRY_PATH   = CURLINFO_STRING + 30,
    REDIRECT_URL     = CURLINFO_STRING + 31,
    PRIMARY_IP       = CURLINFO_STRING + 32,
    APPCONNECT_TIME  = CURLINFO_DOUBLE + 33,
    CERTINFO         = CURLINFO_PTR    + 34,
    CONDITION_UNMET  = CURLINFO_LONG   + 35,
    RTSP_SESSION_ID  = CURLINFO_STRING + 36,
    RTSP_CLIENT_CSEQ = CURLINFO_LONG   + 37,
    RTSP_SERVER_CSEQ = CURLINFO_LONG   + 38,
    RTSP_CSEQ_RECV   = CURLINFO_LONG   + 39,
    PRIMARY_PORT     = CURLINFO_LONG   + 40,
    LOCAL_IP         = CURLINFO_STRING + 41,
    LOCAL_PORT       = CURLINFO_LONG   + 42,
    TLS_SESSION      = CURLINFO_PTR    + 43,
    ACTIVESOCKET     = CURLINFO_SOCKET + 44,
    TLS_SSL_PTR      = CURLINFO_PTR    + 45,
    HTTP_VERSION     = CURLINFO_LONG   + 46,
    PROXY_SSL_VERIFYRESULT = CURLINFO_LONG + 47,
    PROTOCOL         = CURLINFO_LONG   + 48,
    SCHEME           = CURLINFO_STRING + 49,
    TOTAL_TIME_T     = CURLINFO_OFF_T + 50,
    NAMELOOKUP_TIME_T = CURLINFO_OFF_T + 51,
    CONNECT_TIME_T   = CURLINFO_OFF_T + 52,
    PRETRANSFER_TIME_T = CURLINFO_OFF_T + 53,
    STARTTRANSFER_TIME_T = CURLINFO_OFF_T + 54,
    REDIRECT_TIME_T  = CURLINFO_OFF_T + 55,
    APPCONNECT_TIME_T = CURLINFO_OFF_T + 56,
    RETRY_AFTER      = CURLINFO_OFF_T + 57,
    EFFECTIVE_METHOD = CURLINFO_STRING + 58,
    PROXY_ERROR      = CURLINFO_LONG + 59,
    REFERER          = CURLINFO_STRING + 60, ]#

    LASTONE          = 60
};

macro CURLINFO_HTTP_CODE { CURLINFO::RESPONSE_CODE }

type curl_closepolicy: enum {
    NONE,
    OLDEST,
    LEAST_RECENTLY_USED,
    LEAST_TRAFFIC,
    SLOWEST,
    CALLBACK,

    LAST # never use
};

macro CURL_GLOBAL_SSL { (1 << 0) }
macro CURL_GLOBAL_WIN32 { (1 << 1) }
macro CURL_GLOBAL_ALL { (CURL_GLOBAL_SSL! | CURL_GLOBAL_WIN32!) }
macro CURL_GLOBAL_NOTHING { 0 }
macro CURL_GLOBAL_DEFAULT { CURL_GLOBAL_ALL! }
macro CURL_GLOBAL_ACK_EINTR { (1 << 2) }

#[****************************************************************************
 * Setup defines, protos etc for the sharing stuff.
 ]#

type curl_lock_data: enum {
    NONE,
    SHARE,
    COOKIE,
    DNS,
    SSL_SESSION,
    CONNECT,
    PSL,
    LAST # never use
};

type curl_lock_access: enum {
    NONE,
    SHARED,
    SINGLE,
    LAST # never use
};

type curl_lock_function: fn(&CURL, curl_lock_data, curl_lock_access, &void);
type curl_unlock_function: fn(&CURL, curl_lock_data, &void);

type CURLSHcode: enum {
    OK,
    BAD_OPTION,
    IN_USE,
    INVALID,
    NOMEM,
    NOT_BUILT_IN,
    LAST # never use
};

type CURLSHoption: enum {
    NONE,
    SHARE,
    UNSHARE,
    LOCKFUNC,
    UNLOCKFUNC,
    USERDATA,
    LAST # never use
};

extern {
    fn curl_share_init(): &CURLSH;
    fn curl_share_setopt(c: &CURLSH, option: CURLSHoption, args: ...): CURLSHcode;
    fn curl_share_cleanup(c: &CURLSH): &CURLSHcode;
}

type CURLversion: enum {
    FIRST,
    SECOND,
    THIRD,
    FOURTH,
    FIFTH,
    SIXTH,
    SEVENTH,
    EIGHTH,
    NINTH,
    TENTH,
    LAST # never use
};

macro CURLVERSION_NOW { ::CURLversion::TENTH }

type curl_version_info_data: struct {
    age: CURLversion,
    version: const &char,
    version_num: u32,
    host: const &char,
    features: i32,
    ssl_version: const &char,
    ssl_version_num: i64,
    libz_version: const &char,
    protocols: const &const &char,

    ares: const &char,
    ares_num: i32,

    libidn: const &char,

    iconv_ver_num: i32,

    libssh_version: const &char,

    brotli_ver_num: u32,
    brotli_version: const &char,

    nghttp2_ver_num: u32,
    nghttp2_version: const &char,
    quic_versoin: const &char,

    cainfo: const &char,
    capath: const &char,

    zstd_ver_num: u32,
    zstd_version: const &char,

    hyper_version: const &char,

    gsasl_version: const &char
};

macro CURL_VERSION_IPV6         { (1<<0)  } # IPv6-enabled
macro CURL_VERSION_KERBEROS4    { (1<<1)  } # Kerberos V4 auth is supported (deprecated)
macro CURL_VERSION_SSL          { (1<<2)  } # SSL options are present
macro CURL_VERSION_LIBZ         { (1<<3)  } # libz features are present
macro CURL_VERSION_NTLM         { (1<<4)  } # NTLM auth is supported
macro CURL_VERSION_GSSNEGOTIATE { (1<<5)  } # Negotiate auth is supported (deprecated)
macro CURL_VERSION_DEBUG        { (1<<6)  } # Built with debug capabilities
macro CURL_VERSION_ASYNCHDNS    { (1<<7)  } # Asynchronous DNS resolves
macro CURL_VERSION_SPNEGO       { (1<<8)  } # SPNEGO auth is supported
macro CURL_VERSION_LARGEFILE    { (1<<9)  } # Supports files larger than 2GB
macro CURL_VERSION_IDN          { (1<<10) } # Internationized Domain Names are supported
macro CURL_VERSION_SSPI         { (1<<11) } # Built against Windows SSPI
macro CURL_VERSION_CONV         { (1<<12) } # Character conversions supported
macro CURL_VERSION_CURLDEBUG    { (1<<13) } # Debug memory tracking supported
macro CURL_VERSION_TLSAUTH_SRP  { (1<<14) } # TLS-SRP auth is supported
macro CURL_VERSION_NTLM_WB      { (1<<15) } # NTLM delegation to winbind helper is supported
macro CURL_VERSION_HTTP2        { (1<<16) } # HTTP2 support built-in
macro CURL_VERSION_GSSAPI       { (1<<17) } # Built against a GSS-API library
macro CURL_VERSION_KERBEROS5    { (1<<18) } # Kerberos V5 auth is supported
macro CURL_VERSION_UNIX_SOCKETS { (1<<19) } # Unix domain sockets support
macro CURL_VERSION_PSL          { (1<<20) } # Mozilla's Public Suffix List, used for cookie domain verification
macro CURL_VERSION_HTTPS_PROXY  { (1<<21) } # HTTPS-proxy support built-in
macro CURL_VERSION_MULTI_SSL    { (1<<22) } # Multiple SSL backends available
macro CURL_VERSION_BROTLI       { (1<<23) } # Brotli features are present.
macro CURL_VERSION_ALTSVC       { (1<<24) } # Alt-Svc handling built-in
macro CURL_VERSION_HTTP3        { (1<<25) } # HTTP3 support built-in
macro CURL_VERSION_ZSTD         { (1<<26) } # zstd features are present
macro CURL_VERSION_UNICODE      { (1<<27) } # Unicode support on Windows
macro CURL_VERSION_HSTS         { (1<<28) } # HSTS is supported
macro CURL_VERSION_GSASL        { (1<<29) } # libgsasl is supported

extern {
    fn curl_version_info(version: CURLversion): &curl_version_info_data;
    fn curl_easy_stderr(code: CURLcode): const &char;
    fn curl_share_strerror(code: CURLSHcode): const &char;
    fn curl_easy_pause(handle: &CURL, bitmask: i32): CURLcode;
}

macro CURLPAUSE_RECV      { (1<<0) }
macro CURLPAUSE_RECV_CONT { (0) }
macro CURLPAUSE_SEND      { (1<<2) }
macro CURLPAUSE_SEND_CONT { (0) }
macro CURLPAUSE_ALL       { (CURLPAUSE_RECV|CURLPAUSE_SEND) }
macro CURLPAUSE_CONT      { (CURLPAUSE_RECV_CONT|CURLPAUSE_SEND_CONT) }