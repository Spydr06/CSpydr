import "types.csp";

macro max(a, b) {
    (if (a) > (b) => (a) else (b))
}

macro min(a, b) {
    (if (a) < (b) => (a) else (b))
}

namespace std {
    namespace math {
        const PI: f64 = 3.141592653589793;

        namespace __static {

        }

        fn nan(): f32 
        {
            let n = 0x7fc00000;
            <- *((&n): &f32);
        }
        
        fn inf(): f32 
        {
            let i = 0x7f800000;
            <- *((&i): &f32);
        }

        fn pow(a: i32, b: i32): i64 
        {
            match b {
                0 => ret 0;
                1 => ret a;
                2 => ret a²;
                3 => ret a³;
                _ => {
                    let c: i64 = 1;

                    for let i = 0; i < b; i++;
                        c *= a;

                    <- c;
                }
            }
        }

        fn div(num: i32, den: i32): std::div_t
            <- div_t :: {
                num / den,
                num % den
            };
        
        fn ldiv(num: i64, den: i64): std::ldiv_t
            <- ldiv_t :: {
                num / den,
                num % den
            };

        # mathematically correct modulo; the % operator only works properly with positive integers.
        fn mod(num: i64, den: i64): i64
        {
            let result = num % den;
            while result < 0
                result += den;
            <- result;
        }

        fn sqrt(n: f64): f64 
        {
            let r: f64 = 0.0;
            asm "fldl " n ";" 
                "fsqrt;"
                "fstpl " r;
            
            <- r;
        }

        fn abs(a: i32): i32
            <- if a > 0 => a else -a;
        
        fn labs(a: i64): i64
            <- if a > 0 => a else -a;

        
    }
}