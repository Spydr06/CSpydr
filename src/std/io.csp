import "syscall.csp";
import "str.csp";
import "types.csp";
import "utils.csp";

macro stdin  {0}
macro stdout {1}
macro stderr {2}

macro write(fd, v) {
    (
        if (type) (typeof (v)) == i8 ||
            (type) (typeof (v)) == i16 ||
            (type) (typeof (v)) == i32 ||
            (type) (typeof (v)) == i64
        => ::std::io::write_int(fd, (v): i64)
        else if (type) (typeof (v)) == u8 ||
            (type) (typeof (v)) == u16 ||
            (type) (typeof (v)) == u32 ||
            (type) (typeof (v)) == u64
        => ::std::io::write_uint(fd, (v): u64)
        else if (type) (typeof (v)) == &char ||
            (type) (typeof (v)) == char[]
        => ::std::io::write(fd, (v))
        else
        ::std::io::write_ptr(fd, (v)) 
    )
}

namespace std {
    # flags for std::syscall::open
    type OpenFlag: enum {
        APPEND    = 1024,
        ASYNC     = 8192,
        CLOEXEC   = 524288,
        CREAT     = 64,
        DIRECT    = 16384,
        DIRECTORY = 65536,
        DSYNC     = 4096,
        EXCL      = 128,
        LARGEFILE = 32768,
        NOATIME   = 262144,
        NOCTTY    = 256,
        NOFOLLOW  = 131072,
        NONBLOCK  = 2048,
        NDELAY    = 2048,
        PATH      = 2097152,
        SYNC      = 1052672,
        TMPFILE   = 4259840,
        TRUNC     = 512,
    };

    type Stat: struct {
        st_dev: dev_t,
        st_ino: ino_t,
        st_mode: mode_t,
        st_nlink: nlink_t,
        st_uid: uid_t,
        st_gid: gid_t,
        st_rdev: dev_t,
        st_size: off_t,
        st_blksize: blksize_t,
        st_blocks: blkcnt_t,
        st_atime: time_t,
        st_mtime: time_t,
        st_ctime: time_t
    };

    type PollFd: struct {
        fd: i32,
        events: i16,
        revents: i16
    };

    type IOVec: struct {
        iov_base: &void,
        iov_len: usize
    };

    const in: i32 = stdin!;
    const out: i32 = stdout!;
    const err: i32 = stdout!;

    namespace io {
        const EOF: i32 = -1;

        fn puts(str: const &char)  fputs(str, stdout!);
        fn putc(c: char)           fputc(c, stdout!);
        fn eputs(str: const &char) fputs(str, stderr!);
        fn eputc(c: char)          fputc(c, stderr!);

        fn fputs(str: const &char, fp: i32)
        {
            write(fp, str);
            write(fp, "\n");
        }

        fn fputc(c: char, fp: i32)
        {
            let str = [c, '\0'];
            write(fp, str);
        }

        fn close(fd: i32)
        {
            syscall::close(fd); # error handling
        }

        fn printf(fmt: const &char, args: ...): i32
            <- vfprintf(out, fmt, args);

        fn eprintf(fmt: const &char, args: ...): i32
            <- vfprintf(err, fmt, args);

        fn fprintf(fd: i32, fmt: const &char, args: ...): i32
            <- vfprintf(fd, fmt, args);

        fn vfprintf(fd: i32, fmt: const &char, args: &va::Element): i32
        {
            <- 0;
        }

        fn write(fd: i32, buf: const &char) 
        {
            if syscall::write(fd, buf, c_str::strlen(buf) + 1) <= 0
            {
                # todo: fail assertion
                ret;
            }
        }

        fn writeln(fd: i32, buf: const &char)
        {
            if syscall::write(fd, buf, c_str::strlen(buf) + 1) <= 0
            {
                # todo: fail assertion
                ret;
            }

            if syscall::write(fd, "\n", 2) <= 0
            {
                # todo: fail assertion
                ret;
            }
        }

        fn write_int(fd: i32, int: i64)
        {
            let buf: char[32];
            mem::zero(buf, sizeof char * len buf);

            c_str::from_int(int, buf, 10);
            write(fd, buf);
        }

        fn write_uint(fd: i32, uint: u64)
        {

        }

        fn write_ptr(fd: i32, ptr: &void)
        {
            
        }
    }
}