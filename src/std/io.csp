import "syscall.csp";
import "str.csp";
import "types.csp";
import "utils.csp";

macro stdin  {0}
macro stdout {1}
macro stderr {2}

macro write(fd, v) {
    (
        if type::((typeof (v)) == i8) ||
            type::((typeof (v)) == i16) ||
            type::((typeof (v)) == i32) ||
            type::((typeof (v)) == i64)
        => ::std::io::write_int(fd, (v): i64)
        else if type::((typeof (v)) == u8) ||
            type::((typeof (v)) == u16) ||
            type::((typeof (v)) == u32) ||
            type::((typeof (v)) == u64)
        => ::std::io::write_uint(fd, (v): u64)
        else if type::((typeof (v)) == &char) ||
            type::((typeof (v)) == char[])
        => ::std::io::write(fd, (v))
        else
        ::std::io::write_ptr(fd, (v)) 
    )
}

namespace std {
    type Stat: struct {
        dev: dev_t,         # Device
        ino: ino_t,         # File serial number
        mode: mode_t,       # File mode
        nlink: nlink_t,     # Link count
        uid: uid_t,         # User ID of the file's owner
        gid: gid_t,         # Group ID of the file's owner
        rdev: dev_t,        # Device number, if device
        size: off_t,        # Sote of the file (in bytes)
        blksize: blksize_t, # Optimal blocksize for IO
        blocks: blkcnt_t,   # Number 512-byte blocks allocated
        atime: time_t,
        atimensec: u64,
        mtime: time_t,
        mtimensec: u64,
        ctime: time_t,
        ctimensec: u64,
        __glibc_reserved: struct {_0: u64, _1: u64, _2: u64}
    };

    type PollFd: struct {
        fd: i32,
        events: i16,
        revents: i16
    };

    type IOVec: struct {
        iov_base: &void,
        iov_len: usize
    };

    type FLock: struct {
        l_type: i16,
        l_whence: i16,
        l_start: off_t,
        l_len: off_t,
        l_pid: pid_t
    };

    const in: i32 = stdin!;
    const out: i32 = stdout!;
    const err: i32 = stdout!;

    namespace io {
        const O_RDONLY: i32 = 0;
        const O_WRONLY: i32 = 1;
        const O_RDWR: i32   = 2;
        const O_CREAT: i32  = 64;

        const F_OK: i32    = 0;
        const R_OK: i32    = 4;
        const W_OK: i32    = 2;
        const X_OK: i32    = 1;
        const F_ULOCK: i32 = 0;
        const F_LOCK: i32  = 1;
        const F_TLOCK: i32 = 2;
        const F_TEST: i32  = 3;

        const F_SETLEASE: i32   = 1024;
        const F_GETLEASE: i32   = 1025;
        const F_NOTIFY: i32     = 1026;
        const F_CANCELLK: i32   = 1029;
        const F_SETPIPE_SZ: i32	= 1031;
        const F_GETPIPE_SZ: i32	= 1032;
        const F_ADD_SEALS: i32  = 1033;
        const F_GET_SEALS: i32  = 1034;
        
        const F_SEAL_SEAL: i32         = 0x0001;
        const F_SEAL_SHRINK: i32       = 0x0002;
        const F_SEAL_GROW: i32	       = 0x0004;
        const F_SEAL_WRITE: i32	       = 0x0008;
        const F_SEAL_FUTURE_WRITE: i32 = 0x0010;
        
        const F_GET_RW_HINT: i32      = 1035;
        const F_SET_RW_HINT: i32      = 1036;
        const F_GET_FILE_RW_HINT: i32 = 1037;
        const F_SET_FILE_RW_HINT: i32 = 1038;
        
        const RWF_WRITE_LIFE_NOT_SET: i32 = 0;
        const RWH_WRITE_LIFE_NONE: i32	  = 1;
        const RWH_WRITE_LIFE_SHORT: i32	  = 2;
        const RWH_WRITE_LIFE_MEDIUM: i32  = 3;
        const RWH_WRITE_LIFE_LONG: i32	  = 4;
        const RWH_WRITE_LIFE_EXTREME: i32 = 5;
        
        const DN_ACCESS: i32 = 0x00000001;
        const DN_MODIFY: i32 = 0x00000002;
        const DN_CREATE: i32 = 0x00000004;
        const DN_DELETE: i32 = 0x00000008;
        const DN_RENAME: i32 = 0x00000010;
        const DN_ATTRIB: i32 = 0x00000020;
        const DN_MULTISHOT: i32 = 0x80000000;

        const LOCK_SH: i32 = 1;
        const LOCK_EX: i32 = 2;
        const LOCK_NB: i32 = 4;
        const LOCK_UN: i32 = 8;

        const L_SET: i32 = 0;
        const L_INCR: i32 = 1;
        const L_XTND: i32 = 2;
        
        const EOF: char = '\0';

        fn puts(str: const &char)  fputs(str, stdout!);
        fn putc(c: char)           fputc(c, stdout!);
        fn eputs(str: const &char) fputs(str, stderr!);
        fn eputc(c: char)          fputc(c, stderr!);

        fn getc(): char ret fgetc(stdin!);

        fn fputs(str: const &char, fd: i32)
        {
            write(fd, str);
            write(fd, "\n");
        }

        fn fputc(c: char, fd: i32)
        {
            syscall::write(fd, &c, 1);
        }

        fn fgetc(fd: i32): char
        {
            let c = '\0';
            syscall::read(fd, &c, 1);
            <- c;
        }

        fn close(fd: i32)
        {
            syscall::close(fd); # error handling
        }

        fn printf(fmt: const &char, args: ...): i32
            <- vfprintf(out, fmt, &args);

        fn eprintf(fmt: const &char, args: ...): i32
            <- vfprintf(err, fmt, &args);

        fn fprintf(fd: i32, fmt: const &char, args: ...): i32
            <- vfprintf(fd, fmt, &args);

        fn vfprintf(fd: i32, fmt: const &char, args: &VAList): i32
        {
            using string;

            with formatted = va_format(fmt, args)
                write(fd, formatted);
            
            <- 0;
        }

        fn write(fd: i32, buf: const &char) 
        {
            if syscall::write(fd, buf, c_str::strlen(buf)) <= 0
            {
                # todo: fail assertion
                ret;
            }
        }

        fn writeln(fd: i32, buf: const &char)
        {
            if syscall::write(fd, buf, c_str::strlen(buf) + 1) <= 0
            {
                # todo: fail assertion
                ret;
            }

            if syscall::write(fd, "\n", 2) <= 0
            {
                # todo: fail assertion
                ret;
            }
        }

        fn write_int(fd: i32, int: i64)
        {
            let buf: &char = mem::alloc(32);
            mem::zero(buf, sizeof char * 32);

            c_str::from_int(int, buf, 10);
            write(fd, buf);
            mem::free(buf);
        }

        fn write_uint(fd: i32, uint: u64)
        {

        }

        fn write_ptr(fd: i32, ptr: &void)
        {
            
        }

        [ignore_unused("*")]
    }
}