import "syscall.csp";
import "types.csp";
import "utils.csp";

# macros for quick access
macro alloc(size) { (::std::mem::alloc(size)) }
macro realloc(src, size) { (::std::mem::realloc(src, size)) }
macro free(ptr) { (::std::mem::free(ptr)) }

# actual memory allocator implementation
namespace std {
    # memory protection types for std::syscall::mmap
    type Prot: enum {
        NONE,
        READ,
        WRITE,
        EXEC
    };  

    # flags for std::syscall::mmap
    type Map: enum {
        SHARED  = 0x01,
        PRIVATE = 0x02,
        FIXED   = 0x10,
        ANON    = 0x20,
    };

    namespace mem {
        const MMAP_FAILED: &void = -1;

        fn alloc(size: usize): &void
        {
            let length = size + sizeof usize;
            let plen: &usize = syscall::mmap(0, length, Prot::READ | Prot::WRITE, Map::PRIVATE | Map::ANON, 0, 0);
            if plen == MMAP_FAILED ret nil;
            
            *plen = length;
            <- (&plen[1]): &void;
        }

        fn realloc(src: &void, size: usize): &void
        {
            let new = alloc(size);
            copy(new, src, size);
            free(src);
            <- new;
        }

        fn free(ptr: &void)
        {
            if ptr == nil ret;

            let plen = &(ptr: &usize)[-1];
            let length = *plen;

            syscall::munmap(plen: &void, length);
        }

        fn copy(dest: &void, src: &void, n: usize): i32
        {
            if ptr_overlap(dest, src, n) ret -1; # error

            let x: &u8 = dest;
            let y: &u8 = src;

            for let i: usize = 0; i < n; i++;
                x[i] = y[i];

            <- 0; # success
        }

        fn eq(a: &void, b: &void, n: usize): bool
        {
            let x: &u8 = a;
            let y: &u8 = b;

            for let i: usize = 0; i < n; i++;
                if x[i] != y[i] ret false; # not equal

            <- true; # equal
        }

        # function to check if two pointer overlap
        fn ptr_overlap(a: &void, b: &void, n: usize): bool
        {
            let x: &u8 = a;
            let y: &u8 = b;
            <- (x <= y && x + n > y) || (y <= x && y + n > x);
        }
    }
}