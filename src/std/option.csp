macro some(value) 
{
    (::std::option::some((value): &void))
}

macro none()
{
    (::std::option::none())
}

macro ok(value)
{
    (::std::result::ok((value): &void))
}

macro err(value)
{
    (::std::result::err((value): &void))
}

macro unwrap(opt)
{   (
        if type::(typeof (opt) == ::std::Option)
        => ::std::option::unwrap((opt))
        else ::std::result::unwrap((opt))
    )
}

macro unwrap_or(opt, then)
{
    (
        if type::(typeof (opt) == ::std::Option)
        => ::std::option::unwrap_or((opt), (then): fn<&void>())
        else ::std::result::unwrap_or((opt), (then): fn<&void>(&void))
    )
}

namespace std {
    type Option: struct {
        is_some: bool,
        value: &void
    };

    namespace option {
        fn init(is_some: bool, value: &void): std::Option
            <- Option :: {is_some, value};

        fn some(value: &void): std::Option
            <- init(true, value);

        fn none(): std::Option
            <- init(false, nil);

        fn is_some(opt: Option): bool
            <- opt.is_some;
        
        fn is_none(opt: Option): bool
            <- !opt.is_some;
        
        fn unwrap(opt: Option): &void
            <- if opt.is_some => opt.value else nil;

        fn unwrap_or(opt: Option, then: fn<&void>()): &void
            <- if opt.is_some => opt.value else then();
    }

    type Result: struct {
        is_err: bool,
        value: &void
    };

    namespace result {
        fn init(is_err: bool, value: &void): std::Result
            <- Result :: {is_err, value};
        
        fn err(value: &void): std::Result
            <- init(true, value);
        
        fn ok(value: &void): std::Result
            <- init(false, value);
        
        fn is_ok(res: Result): bool
            <- !res.is_err;
        
        fn is_err(res: Result): bool
            <- res.is_err;
        
        fn unwrap(res: Result): &void
            <- if !res.is_err => res.value else nil;
        
        fn unwrap_err(res: Result): &void
            <- if res.is_err => res.value else nil;
        
        fn unwrap_or(res: Result, then: fn<&void>(&void)): &void
            <- if res.is_err => then(res.value) else res.value;
    }
}