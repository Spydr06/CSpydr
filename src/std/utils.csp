import "mem.csp";

macro each(i, lo, hi) 
{
    let i = lo; i < hi; i++
}

macro range(lo, hi)
{
    let i = lo; i < hi; i++
}

macro xor_swap(a, b)
{
    {
        (a) ^= (b);
        (b) ^= (a);
        (a) ^= (b);
    }
}

macro swap(a, b)
{
    {
        let __swap_tmp = (a);
        (a) = (b);
        (b) = __swap_tmp;
    }
}

macro ttos(ty)
{
    ((type) __to_str(ty))
}

# checks if the bit of v at position p is 1
macro check_bit(v, p)
{
    ((v) & ((1: u64) << (p)))
}

# toggles the bit of v at position v
macro toggle_bit(v, p)
{
    ((v) ^= ((1: u64) << (p)))
}

# sets the bit of v at position p to x
macro set_bit(v, p, x)
{
    ((v) ^= ((-(x)) ^ (v)) & ((1: u64) << (p)))
}

macro va_arg(ap, ty)
{
    (
        *((
            if type::reg_class(ty) == 0
                => ::std::va::__gp((ap), sizeof (ty), alignof (ty))
            else if type::reg_class(ty) == 1
                => ::std::va::__fp((ap), sizeof (ty), alignof (ty))
            else ::std::va::__mem((ap), sizeof (ty), alignof (ty))
        ): &(ty))
    )
}

macro va_copy(dest, src)
{
    (::std::va::copy((dest), (src)))
}

namespace std {
    type VAList: std::va::Element;

    namespace va {
        type Element: struct {
            gp_offset: u32,
            fp_offset: u32,
            overflow_arg_area: &void,
            reg_save_area: &void
        };

        fn __mem(ap: &Element, size: i32, align: i32): &void
        {
            let p: &void = ap.overflow_arg_area;
            if align > 8
                p = (((p + 15) / 16 * 16): &void);
            
            ap.overflow_arg_area = ((((p + size + 7): u64) / 8 * 8): &void);
            <- p;
        }

        fn __gp(ap: &Element, size: i32, align: i32): &void
        {
            if ap.gp_offset >= 48
                <- __mem(ap, size, align);
    
            let r: &void = ap.reg_save_area + (ap.gp_offset: u64);
            ap.gp_offset += 8;
            <- r;
        }

        fn __fp(ap: &Element, size: i32, align: i32): &void
        {
            if ap.fp_offset >= 112
                <- __mem(ap, size, align);
    
            let r: &void = ap.reg_save_area + (ap.fp_offset: u64);
            ap.fp_offset += 8;
            <- r;
        }

        fn copy(dest: &Element, src: &Element)
        {
            (*dest) = *src;
        }
    }

    # utility functions from "ctype.h" of the C standard library
    namespace ctype {
        fn isalnum(c: i32): i32
            <- isalpha(c) != 0 || isdigit(c) != 0;

        fn isalpha(c: i32): i32
            <- (c: u32 | 32) - 'a' < 26;
        
        fn isascii(c: i32): i32
            <- !(c & ~0x7f);
        
        fn isblank(c: i32): i32
            <- c == ' ' || c == '\t';
        
        fn isncntrl(c: i32): i32
            <- c: u32 < 0x20 || c == 0x7f;
        
        fn isdigit(c: i32): i32
            <- c: u32 - '0' < 10;
        
        fn isgraph(c: i32): i32
            <- c: u32 - 0x21 < 0x5e;
        
        fn islower(c: i32): i32
            <- c: u32 - 'a' < 26;
        
        fn isprint(c: i32): i32
            <- c: u32 - 0x20 < 0x5f;
        
        fn ispunct(c: i32): i32
            <- isgraph(c) != 0 && isalnum(c) == 0;
        
        fn isspace(c: i32): i32
            <- c == ' ' || (c: u32 - '\t' < 5);
        
        fn isupper(c: i32): i32
            <- c: u32 - 'A' < 26;
        
        fn toascii(c: i32): i32
            <- c & 0x7f;
        
        fn tolower(c: i32): i32
        {
            if isupper(c)
                <- c | 32;
            <- c;
        }

        fn toupper(c: i32): i32
        {
            if islower(c)
                <- c | 0x5f;
            <- c;
        }
    }
}