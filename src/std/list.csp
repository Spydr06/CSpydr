import "libc/stdlib.csp";

namespace std {
    # the List struct
    type List: struct {
        length: u64,    # number of elements in the list
        allocated: u64, # number of allocated bytes
        data: &&void    # the actual data
    };

    namespace list {
        # steps, in which the list gets allocated 
        const ALLOC_SIZE = 128;
        
        # initializes a List type
        fn init(): &::std::List {
            let list: &List = malloc(sizeof List);
            list.allocated = 0;
            list.length = 0;
            list.data = nil;

            <- list;
        }

        # adds a void pointer to the list, if needed, allocate more memory
        fn add(list: &List, item: &void) {
            list.length++;

            if list.allocated < list.length {
                if list.allocated == 0 {
                    list.allocated = ALLOC_SIZE;
                    list.data = calloc(list.allocated, sizeof &void);
                } 
                else {
                    list.allocated = list.allocated + ALLOC_SIZE;
                    list.data = realloc(list.data, list.allocated * sizeof &void);
                }
            }

            list.data[list.length - 1] = item;
        }

        # iterate over every item of the list
        fn for_each(list: &List, lambda: fn<void>(u64, &void))
            for let i: u64 = 0; i < list.length; i++;
                lambda(i, list.data[i]);

        # joint two lists together
        fn join(dest: &List, src: &List) {
            for let i: u64 = 0; i < src.length; i++
                add(dest, src.data[i]);

        # gets the value at an index
        fn get(list: &List, index: u64): &void {
            if list.length > index
                <- list.data[index];
            <- nil;
        }

        fn size(list: &List): u64 {
            <- list.length;
        }

        # frees a list
        fn free(list: &List) {
            if list.allocated > 0
                ::free(list.data);
            ::free(list);
        }
    }
}