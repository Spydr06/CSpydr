import "libc/stdlib.csp";

namespace std {
    type Stack: struct {
        size: u64,
        allocated: u64,
        data: &&void
    };

    namespace stack {
        const ALLOC_SIZE = 128;

        fn init(): &::std::Stack {
            let stack: &Stack = malloc(sizeof Stack);
            stack.allocated = 0;
            stack.size = 0;
            stack.data = nil;

            <- stack;
        }

        fn push(stack: &Stack, item: &void) {
            stack.size++;

            if stack.allocated < stack.size {
                if stack.allocated == 0 {
                    stack.allocated = ALLOC_SIZE;
                    stack.data = calloc(stack.allocated, sizeof &void);
                } 
                else {
                    stack.allocated = stack.allocated + ALLOC_SIZE;
                    stack.data = realloc(stack.data, stack.allocated * sizeof &void);
                }
            }

            stack.data[stack.size - 1] = item;
        }

        fn pop(stack: &Stack): &void {
            if is_empty(stack)
                <- nil;

            let data = top(stack);

            stack.size--;
            stack.data[stack.size] = nil;
            <- data;
        }

        fn peek(stack: &Stack, offset: u64): &void {
            if stack.size - 1 - offset < 0
                <- nil;

            <- stack.data[stack.size - 1 - offset];
        }

        fn is_empty(stack: &Stack): bool {
            <- stack.size == 0;
        }

        fn top(stack: &Stack): &void {
            if is_empty(stack)
                <- nil;
            <- stack.data[stack.size - 1];
        }

        fn bottom(stack: &Stack): &void {
            if is_empty(stack)
                <- nil;
            <- stack.data[0];
        }

        fn free(stack: &Stack) {
            if stack.allocated > 0
                ::free(stack.data);
            ::free(stack);
        }
    }
}