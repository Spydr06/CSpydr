# a basic test program used for developing this programming language 

##
@derive(compile_type, transpile);
@derive(include_dirs, {
    "./examples",
    "std"
});
##

# TODO: add missing C operators: >>, <<, =>>, <<=, |, &, |=, &=, ^, ^=, %, %=

import "vec.csp";
import "string.csp";

macro message() |: init_str("Hello World") :|

fn main(argc: i32, argv: &&char): i32 {
    let string: str = message!;
    str_append(string, '!');

    printf("str: %s\n", str_lit(string));

    free_str(string);

    lambda_test(|x: i32, y: i32| i32 => ret x + y;);
    lambda_test(lambda_test_fn);

    let tuple: [i32, bool] = tuple_test(); 

    <- 0;
}

let test_arr: i32[] = [4, 5];

fn lambda_test_fn(x: i32, y: i32): i32 {
    <- x - y;
}

fn lambda_test(lambda: fn<i32>(i32, i32)) {
    printf("lambda: %d\n", lambda(test_arr[1], test_arr[0]));
}

fn tuple_test(): [i32, bool] {
    <- {4, true};
}

# Some plans for generics:
##fn generic_test<T>() {
    let x: T = 0;
    printf("typeof t: %s\n", typeof T);
}

type Pair: struct<K, V> {
    key: K,
    val: V
}

fn new_pair<K, V>(key: K, val: V): Pair {
    let pair: Pair<K, V> = malloc(sizeof(Pair<K, V>));
    pair.key = key;
    pair.val = val;

    return pair;
}

##

# Idea for macro argument implementation:
##
macro x(a, b) |: printf("-> $a is %d\n-> $b is %d", $a, $b); :|
##